{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"New to cognee?","text":"<p>The getting started guide covers adding a cognee data store to your AI app, sending data, identifying users, extracting actions and insights, and interconnecting separate datasets.</p> <p>Get started</p>"},{"location":"#ingest-data","title":"Ingest Data","text":"<p>Learn how to manage the ingestion of events, customer data, or third-party data for use with cognee.</p> <p>Explore</p>"},{"location":"#tasks-and-pipelines","title":"Tasks and Pipelines","text":"<p>Analyze and enrich your data and improve LLM answers with a series of tasks and pipelines.</p> <p>Learn about tasks</p>"},{"location":"#api","title":"API","text":"<p>Push or pull data to build custom functionality or create bespoke views for your business needs.</p> <p>Explore</p>"},{"location":"#resources","title":"Resources","text":""},{"location":"#resources_1","title":"Resources","text":"<ul> <li>Research</li> <li>Community</li> </ul>"},{"location":"api_reference/","title":"Cognee API Reference","text":""},{"location":"api_reference/#overview","title":"Overview","text":"<p>The Cognee API provides a set of endpoints for managing datasets, performing cognitive tasks, and configuring various settings in the system. The API is built on FastAPI and includes multiple routes to handle different functionalities. This reference outlines the available endpoints and their usage.</p>"},{"location":"api_reference/#base-url","title":"Base URL","text":"<p>The base URL for all API requests is determined by the server's deployment environment. Typically, this will be:</p> <ul> <li>Development: <code>http://localhost:8000</code></li> <li>Production: Depending on your server setup.</li> </ul>"},{"location":"api_reference/#endpoints","title":"Endpoints","text":""},{"location":"api_reference/#1-root","title":"1. Root","text":"<ul> <li>URL: <code>/</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Root endpoint that returns a welcome message.</li> </ul> <p>Response:   <pre><code>{\n  \"message\": \"Hello, World, I am alive!\"\n}\n</code></pre></p>"},{"location":"api_reference/#2-health-check","title":"2. Health Check","text":"<ul> <li>URL: <code>/health</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Health check endpoint that returns the server status.</li> </ul> <p>Response:   <pre><code>{\n  \"status\": \"OK\"\n}\n</code></pre></p>"},{"location":"api_reference/#3-get-datasets","title":"3. Get Datasets","text":"<ul> <li>URL: <code>/datasets</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Retrieve a list of available datasets.</li> </ul> <p>Response:   <pre><code>[\n  {\n    \"id\": \"dataset_id_1\",\n    \"name\": \"Dataset Name 1\",\n    \"description\": \"Description of Dataset 1\",\n    ...\n  },\n  ...\n]\n</code></pre></p>"},{"location":"api_reference/#4-delete-dataset","title":"4. Delete Dataset","text":"<ul> <li>URL: <code>/datasets/{dataset_id}</code></li> <li>Method: <code>DELETE</code></li> <li>Auth Required: No</li> <li>Description: Delete a specific dataset by its ID.</li> </ul> <p>Path Parameters:   - <code>dataset_id</code>: The ID of the dataset to delete.</p> <p>Response:   <pre><code>{\n  \"status\": \"OK\"\n}\n</code></pre></p>"},{"location":"api_reference/#5-get-dataset-graph","title":"5. Get Dataset Graph","text":"<ul> <li>URL: <code>/datasets/{dataset_id}/graph</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Retrieve the graph visualization URL for a specific dataset.</li> </ul> <p>Path Parameters:   - <code>dataset_id</code>: The ID of the dataset.</p> <p>Response:   <pre><code>\"http://example.com/path/to/graph\"\n</code></pre></p>"},{"location":"api_reference/#6-get-dataset-data","title":"6. Get Dataset Data","text":"<ul> <li>URL: <code>/datasets/{dataset_id}/data</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Retrieve data associated with a specific dataset.</li> </ul> <p>Path Parameters:   - <code>dataset_id</code>: The ID of the dataset.</p> <p>Response:   <pre><code>[\n  {\n    \"data_id\": \"data_id_1\",\n    \"content\": \"Data content here\",\n    ...\n  },\n  ...\n]\n</code></pre></p>"},{"location":"api_reference/#7-get-dataset-status","title":"7. Get Dataset Status","text":"<ul> <li>URL: <code>/datasets/status</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Retrieve the status of one or more datasets.</li> </ul> <p>Query Parameters:   - <code>dataset</code>: A list of dataset IDs to check status for.</p> <p>Response:   <pre><code>{\n  \"dataset_id_1\": \"Status 1\",\n  \"dataset_id_2\": \"Status 2\",\n  ...\n}\n</code></pre></p>"},{"location":"api_reference/#8-get-raw-data","title":"8. Get Raw Data","text":"<ul> <li>URL: <code>/datasets/{dataset_id}/data/{data_id}/raw</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Retrieve the raw data file for a specific data entry in a dataset.</li> </ul> <p>Path Parameters:   - <code>dataset_id</code>: The ID of the dataset.   - <code>data_id</code>: The ID of the data entry.</p> <p>Response: Raw file download.</p>"},{"location":"api_reference/#9-add-data","title":"9. Add Data","text":"<ul> <li>URL: <code>/add</code></li> <li>Method: <code>POST</code></li> <li>Auth Required: No</li> <li>Description: Add new data to a dataset. The data can be uploaded from a file or a URL.</li> </ul> <p>Form Parameters:   - <code>datasetId</code>: The ID of the dataset to add data to.   - <code>data</code>: A list of files to upload.</p> <p>Request <pre><code>{\n  \"dataset_id\": \"ID_OF_THE_DATASET_TO_PUT_DATA_IN\", // Optional, we use \"main\" as default.\n  \"files\": File[]\n}\n</code></pre></p> <p>Response:   <pre><code>{\n  \"message\": \"OK\"\n}\n</code></pre></p>"},{"location":"api_reference/#10-cognify","title":"10. Cognify","text":"<ul> <li>URL: <code>/cognify</code></li> <li>Method: <code>POST</code></li> <li>Auth Required: No</li> <li>Description: Perform cognitive processing on the specified datasets.</li> </ul> <p>Request Body:   <pre><code>{\n  \"datasets\": [\"ID_OF_THE_DATASET_1\", \"ID_OF_THE_DATASET_2\", ...]\n}\n</code></pre></p> <p>Response:   <pre><code>{\n  \"message\": \"OK\"\n}\n</code></pre></p>"},{"location":"api_reference/#11-search","title":"11. Search","text":"<ul> <li>URL: <code>/search</code></li> <li>Method: <code>POST</code></li> <li>Auth Required: No</li> <li>Description: Search for nodes in the graph based on the provided query parameters.</li> </ul> <p>Request Body:   <pre><code>{\n  \"query_params\": [{\n    \"query\": \"QUERY_TO_MATCH_DATA\",\n    \"searchType\": \"SIMILARITY\", // or TRAVERSE, ADJACENT, SUMMARY\n  }]\n}\n</code></pre> Response <pre><code>{\n  \"results\": [\n    {\n      \"node_id\": \"node_id_1\",\n      \"attributes\": {...},\n      ...\n    },\n    ...\n  ]\n}\n</code></pre></p>"},{"location":"api_reference/#12-get-settings","title":"12. Get Settings","text":"<ul> <li>URL: <code>/settings</code></li> <li>Method: <code>GET</code></li> <li>Auth Required: No</li> <li>Description: Retrieve the current system settings.</li> </ul> <p>Response:   <pre><code>{\n  \"llm\": {...},\n  \"vectorDB\": {...},\n  ...\n}\n</code></pre></p>"},{"location":"api_reference/#13-save-settings","title":"13. Save Settings","text":"<ul> <li>URL: <code>/settings</code></li> <li>Method: <code>POST</code></li> <li>Auth Required: No</li> <li>Description: Save new settings for the system, including LLM and vector DB configurations.</li> </ul> <p>Request Body:   - <code>llm</code>: Optional. The configuration for the LLM provider.   - <code>vectorDB</code>: Optional. The configuration for the vector database provider.</p> <p>Response:   <pre><code>{\n  \"status\": \"OK\"\n}\n</code></pre></p>"},{"location":"conceptual_overview/","title":"Conceptual Overview - cognee","text":""},{"location":"conceptual_overview/#introduction","title":"Introduction","text":"<p>What is cognee?</p> <p>cognee is a data processing framework that enables LLMs to produce deterministic and traceable outputs.</p> <p>cognee assists developers in introducing greater predictability and management into their Retrieval-Augmented Generation (RAG) workflows through the use of graph architectures, vector stores, and auto-optimizing pipelines.</p> <p>Displaying information as a graph is the clearest way to grasp the content of your documents. Crucially, graphs allow systematic navigation and extraction of data from documents based on their hierarchy.</p>"},{"location":"conceptual_overview/#core-concepts","title":"Core Concepts","text":""},{"location":"conceptual_overview/#concept-1-data-pipelines","title":"Concept 1: Data Pipelines","text":"<p>Most of the data we provide to a system can be categorized as unstructured, semi-structured, or structured. Rows from a database would belong to structured data, jsons to semi-structured data, and logs that we input into the system could be considered unstructured. To organize and process this data, we need to ensure we have custom loaders for all data types, which can help us unify and organize it properly.</p> <p></p> Data Pipeline Example <p>In the example above, we have a pipeline in which data has been imported from various sources, normalized, and stored in a database. Relevant identifiers and relationships between the data are also created in this process. To create an effective data pipeline for processing various types of data\u2014structured, semi-structured, and unstructured\u2014it\u2019s crucial to understand each type's specific handling and processing needs. Let's expand on the concepts involved in setting up such a data pipeline.</p> <p>Data Types and Their Handling - Structured Data: This includes data that adheres to a fixed schema, such as rows in a relational database or data in CSV files. The processing of structured data typically involves SQL queries for extraction, transformations through simple functions or procedures, and loading into destination tables or databases.</p> <ul> <li> <p>Semi-structured Data: JSON files, XML, or even some APIs' data fit this category. These data types don't have a rigid schema but have some organizational properties that can be exploited. Semi-structured data often requires parsers that can navigate its structure (like trees for XML or key-value pairs for JSON) to extract necessary information. Libraries such as json in Python or lxml for XML handling can be very useful here.</p> </li> <li> <p>Unstructured Data: This category includes text files, logs, or even images and videos. </p> </li> </ul>"},{"location":"conceptual_overview/#concept-2-data-enrichment-with-llms","title":"Concept 2: Data Enrichment with LLMs","text":"<p>LLMs are adept at processing unstructured data. They can easily extract summaries, keywords, and other useful information from documents. We use function calling with Pydantic models to extract information from the unstructured data.</p> <p></p> Data Enrichment Example <p>We decompose the loaded content into graphs, allowing us to more precisely map out the relationships between entities and concepts.</p>"},{"location":"conceptual_overview/#concept-3-graphs","title":"Concept 3: Graphs","text":"<p>Knowledge graphs simply map out knowledge, linking specific facts and their connections.  When Large Language Models (LLMs) process text, they infer these links, leading to occasional inaccuracies due to their probabilistic nature. </p> <p>Clearly defined relationships enhance their accuracy.  </p> <p>This structured approach can extend beyond concepts to document layouts, pages, or other organizational schemas.</p> <p></p> Graph Structure"},{"location":"conceptual_overview/#concept-4-vector-and-graph-retrieval","title":"Concept 4: Vector and Graph Retrieval","text":"<p>Cognee lets you use multiple vector and graph retrieval methods to find the most relevant information.</p> <p>Learn more?</p> <p>Check out learning materials to see how you can use these methods in your projects.</p>"},{"location":"conceptual_overview/#concept-5-auto-optimizing-pipelines","title":"Concept 5: Auto-Optimizing Pipelines","text":"<p>Integrating knowledge graphs into Retrieval-Augmented Generation (RAG) pipelines leads to an intriguing outcome: the system's adeptness at contextual understanding allows it to be evaluated in a way Machine Learning (ML) engineers are accustomed to. </p> <p>This involves bombarding the RAG system with hundreds of synthetic questions, enabling the knowledge graph to evolve and refine its context autonomously over time. </p> <p>This method paves the way for developing self-improving memory engines that can adapt to new data and user feedback.</p>"},{"location":"conceptual_overview/#architecture-overview","title":"Architecture Overview","text":"<p>A high-level diagram of cognee's architecture, illustrating the main components and their interactions.</p> <p></p> Architecture <p>Main components:</p> <ul> <li>Data Pipelines: Responsible for ingesting, processing, and transforming data from various sources.</li> <li>LLMs: Large Language Models that process unstructured data and generate text.</li> <li>Graph Store: Knowledge graphs that represent relationships between entities and concepts.</li> <li>Vector Store: Database that stores vector representations of data for efficient retrieval.</li> <li>Search: Retrieves relevant information from the knowledge graph and vector stores.</li> </ul>"},{"location":"conceptual_overview/#how-it-fits-into-your-projects","title":"How It Fits Into Your Projects","text":"<p>How cognee fits into your projects</p> <p>cognee is a self-contained library that simplifies the process of loading and structuring data in LLMs.</p> <p>By integrating cognee into your data pipelines, you can leverage the power of LLMs, knowledge graphs, and vector retrieval to create accurate and explainable AI solutions. cognee provides a self-contained library that simplifies the process of loading and structuring LLM context, enabling you to create accurate and explainable AI solutions.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#configure-vector-and-graph-stores","title":"\ud83d\ude80 Configure Vector and Graph Stores","text":"<p>You can configure the vector and graph stores using the environment variables in your .env file or programatically. We use Pydantic Settings</p> <p>We have a global configuration object (cognee.config) and individual configurations on pipeline and data store levels</p> <p>Check available configuration options: <pre><code>from cognee.infrastructure.databases.vector import get_vectordb_config\nfrom cognee.infrastructure.databases.graph.config import get_graph_config\nfrom cognee.infrastructure.databases.relational import get_relational_config\nprint(get_vectordb_config().to_dict())\nprint(get_graph_config().to_dict())\nprint(get_relational_config().to_dict())\n</code></pre></p> <p>Setting the environment variables in your .env file, and Pydantic will pick them up:</p> <p><pre><code>GRAPH_DATABASE_PROVIDER = 'lancedb'\n</code></pre> Otherwise, you can set the configuration yourself:</p> <pre><code>cognee.config.llm_provider = 'ollama'\n</code></pre>"},{"location":"configuration/#getting-started-with-local-models","title":"\ud83d\ude80 Getting Started with Local Models","text":"<p>You'll need to run the local model on your machine or use one of the providers hosting the model.</p> <p>We had some success with mixtral, but 7b models did not work well. We recommend using mixtral for now.</p>"},{"location":"configuration/#ollama","title":"Ollama","text":"<p>Set up Ollama by following instructions on Ollama website</p> <p>Set the environment variable in your .env to use the model</p> <p><pre><code>LLM_PROVIDER = 'ollama'\n</code></pre> Otherwise, you can set the configuration for the model:</p> <p><pre><code>cognee.config.llm_provider = 'ollama'\n</code></pre> You can also set the HOST and model name:</p> <pre><code>cognee.config.llm_endpoint = \"http://localhost:11434/v1\"\ncognee.config.llm_model = \"mistral:instruct\"\n</code></pre>"},{"location":"configuration/#anyscale","title":"Anyscale","text":"<p><pre><code>LLM_PROVIDER = 'custom'\n</code></pre> Otherwise, you can set the configuration for the model:</p> <p><pre><code>cognee.config.llm_provider = 'custom'\n</code></pre> You can also set the HOST  and model name: <pre><code>LLM_MODEL = \"mistralai/Mixtral-8x7B-Instruct-v0.1\"\nLLM_ENDPOINT = \"https://api.endpoints.anyscale.com/v1\"\nLLM_API_KEY = \"your_api_key\"\n</code></pre></p> <p>You can set the same way HOST and model name for any other provider that has an API endpoint.</p>"},{"location":"data_engineering_llm_ops/","title":"Data Engineering and LLMOps","text":"<p>This is a work in progress and any feedback is welcome</p>"},{"location":"data_engineering_llm_ops/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Data Engineering</li> <li>Large Language Model Operations (LLM Ops)</li> </ol>"},{"location":"data_engineering_llm_ops/#data-engineering","title":"Data Engineering","text":"<p>Data Engineering focuses on managing and analyzing big data. It revolves around five key aspects:</p>"},{"location":"data_engineering_llm_ops/#volume","title":"Volume","text":"<p>The size and amount of data that companies manage and analyze.</p>"},{"location":"data_engineering_llm_ops/#value","title":"Value","text":"<p>The insights and patterns derived from data that lead to business benefits.</p>"},{"location":"data_engineering_llm_ops/#variety","title":"Variety","text":"<p>The diversity of data types, including unstructured, semi-structured, and raw data.</p>"},{"location":"data_engineering_llm_ops/#velocity","title":"Velocity","text":"<p>The speed at which data is received, stored, and managed.</p>"},{"location":"data_engineering_llm_ops/#veracity","title":"Veracity","text":"<p>The accuracy or truthfulness of data.</p>"},{"location":"data_engineering_llm_ops/#large-language-model-operations-llm-ops","title":"Large Language Model Operations (LLM Ops)","text":"<p>The emerging field of Large Language Model Operations (LLM Ops) inherits many practices from data engineering. LLM Ops involves the deployment, monitoring, and maintenance of systems using LLMs to manage and build new generation of AI powered applications. </p> <p>For more in-depth information on LLM Ops, see Resource Name.</p>"},{"location":"data_ingestion/","title":"How data ingestion with cognee works","text":""},{"location":"data_ingestion/#why-bother-with-data-ingestion","title":"Why bother with data ingestion?","text":"<p>In order to use cognee, you need to ingest data into the cognee data store.  This data can be events, customer data, or third-party data. </p> <p>In order to build reliable models and pipelines, we need to structure and process various types of datasets and data sources in the same way. Some of the operations like normalization, deduplication, and data cleaning are common across all data sources.</p> <p>This is where cognee comes in. It provides a unified interface to ingest data from various sources and process it in a consistent way. For this we use dlt (Data Loading Tool) which is a part of cognee infrastructure.</p>"},{"location":"data_ingestion/#example","title":"Example","text":"<p>Let's say you have a dataset of customer reviews in a PDF file. You want to ingest this data into cognee and use it to train a model.</p> <p>You can use the following code to ingest the data:</p> <pre><code>dataset_name = \"artificial_intelligence\"\n\nai_text_file_path = os.path.join(pathlib.Path(__file__).parent, \"test_data/artificial-intelligence.pdf\")\nawait cognee.add([ai_text_file_path], dataset_name)\n</code></pre> <p>cognee uses dlt to ingest the data and allows you to use:</p> <ol> <li>SQL databases. Supports PostgreSQL, MySQL, MS SQL Server, BigQuery, Redshift, and more.</li> <li>REST API generic source. Loads data from REST APIs using declarative configuration.</li> <li>OpenAPI source generator. Generates a source from an OpenAPI 3.x spec using the REST API source.</li> <li>Cloud and local storage. Retrieves data from AWS S3, Google Cloud Storage, Azure Blob Storage, local files, and more.</li> </ol>"},{"location":"data_ingestion/#what-happens-under-the-hood","title":"What happens under the hood?","text":"<p>We use dlt as a loader to ingest data into the cognee metadata store. We can ingest data from various sources like SQL databases, REST APIs, OpenAPI specs, and cloud storage. This enables us to have a common data model we can then use to build models and pipelines. The models and pipelines we build in this way end up in the cognee data store, which is a unified interface to access the data.</p>"},{"location":"local_models/","title":"Running cognee with local models","text":""},{"location":"local_models/#getting-started-with-local-models","title":"\ud83d\ude80 Getting Started with Local Models","text":"<p>You'll need to run the local model on your machine or use one of the providers hosting the model.</p> <p>We had some success with mixtral, but 7b models did not work well. We recommend using mixtral for now.</p>"},{"location":"local_models/#ollama","title":"Ollama","text":"<p>Set up Ollama by following instructions on Ollama website</p> <p>Set the environment variable in your .env to use the model</p> <p><pre><code>LLM_PROVIDER = 'ollama'\n</code></pre> Otherwise, you can set the configuration for the model:</p> <p><pre><code>cognee.config.llm_provider = 'ollama'\n</code></pre> You can also set the HOST and model name:</p> <pre><code>cognee.config.llm_endpoint = \"http://localhost:11434/v1\"\ncognee.config.llm_model = \"mistral:instruct\"\n</code></pre>"},{"location":"local_models/#anyscale","title":"Anyscale","text":"<p><pre><code>LLM_PROVIDER = 'custom'\n</code></pre> Otherwise, you can set the configuration for the model:</p> <p><pre><code>cognee.config.llm_provider = 'custom'\n</code></pre> You can also set the HOST  and model name: <pre><code>LLM_MODEL = \"mistralai/Mixtral-8x7B-Instruct-v0.1\"\nLLM_ENDPOINT = \"https://api.endpoints.anyscale.com/v1\"\nLLM_API_KEY = \"your_api_key\"\n</code></pre></p> <p>You can set the same way HOST and model name for any other provider that has an API endpoint.</p>"},{"location":"quickstart/","title":"QUICKSTART","text":"<p>To understand how cognee works check out the conceptual overview</p>"},{"location":"quickstart/#setup","title":"Setup","text":"<p>To run cognee, you will need the following:</p> <ol> <li>A running postgres instance</li> <li>OpenAI API key (Ollama or Anyscale could work as well)</li> </ol> <p>Navigate to cognee folder and run <pre><code>docker compose up postgres\n</code></pre></p> <p>Add your LLM API key to the enviroment variables</p> <p><pre><code>import os\n\nos.environ[\"LLM_API_KEY\"] = \"YOUR_OPENAI_API_KEY\"\n</code></pre> or  <pre><code>cognee.config.llm_api_key = \"YOUR_OPENAI_API_KEY\"\n</code></pre> If you are using Networkx, create an account on Graphistry to vizualize results: <pre><code>   cognee.config.set_graphistry_username = \"YOUR_USERNAME\"\n   cognee.config.set_graphistry_password = \"YOUR_PASSWORD\"\n</code></pre></p>"},{"location":"quickstart/#run","title":"Run","text":"<p>cognee is asynchronous by design, meaning that operations like adding information, processing it, and querying it can run concurrently without blocking the execution of other tasks.  Make sure to await the results of the functions that you call.</p> <pre><code>import cognee\n\ntext = \"\"\"Natural language processing (NLP) is an interdisciplinary\n       subfield of computer science and information retrieval\"\"\"\n\ncognee.add(text) # Add a new piece of information\n\ncognee.cognify() # Use LLMs and cognee to create knowledge\n\nsearch_results = cognee.search(\"SIMILARITY\", {'query': 'Tell me about NLP'}) # Query cognee for the knowledge\n\nfor result_text in search_results[0]:\n    print(result_text)\n</code></pre> <p>In the example above, we add a piece of information to cognee, use LLMs to create a GraphRAG, and then query cognee for the knowledge. cognee is composable and you can build your own cognee pipelines using our templates.</p>"},{"location":"rags/","title":"Rags","text":""},{"location":"rags/#rag-stack","title":"RAG Stack","text":"<p>Core elements of a RAG stack are the building blocks that we can use to get to more personalized and deterministic outputs. </p> <p>This is a work in progress and any feedback is welcome</p>"},{"location":"rags/#what-is-a-rag","title":"What is a RAG?","text":"<p>What is RAG?</p> <p>RAG stands for Retrieval Augmented Generation. It is a model that combines the power of large language models (LLMs) like GPT-4 with the efficiency of information retrieval systems. The goal of RAG is to generate text that is both fluent and factually accurate by retrieving relevant information from a knowledge base.</p> <p>To try building a simple RAG and understand the limitations, check out this simple guide with examples: RAGs: Retrieval-Augmented Generation Explained</p>"},{"location":"rags/#the-building-blocks-of-a-rag-stack","title":"The Building Blocks of a RAG Stack","text":""},{"location":"rags/#1-data-sources","title":"1. Data Sources","text":"<p>You can get your data from a variety of sources, including:</p> <ul> <li>APIs like Twitter, Reddit, and Google</li> <li>Web scraping tools like Scrapy and Beautiful Soup</li> <li>Documents like PDFs, Word, and Excel files</li> <li>Relational databases like DuckDB, PSQL and MySQL</li> <li>Data warehouses like Snowflake and Databricks</li> <li>Customer data platforms like Segment</li> </ul> <p></p> Some data sources <p>The goal here is to give the data structure and connect it so that it can be used in your deterministic LLM stack.</p>"},{"location":"rags/#2-data-loaders","title":"2. Data Loaders","text":"Data Loaders <p>Data loading into a data lake or warehouse involves using tools like Apache Airflow, dlt, dbt, and Databricks. The process includes data extraction, transformation, and loading for model usage, aiming for a clean, structured dataset ready for enrichment. Check out how we do it with dlt: Data Loading Tool (dlt)</p>"},{"location":"rags/#3-vector-computation-and-vector-stores","title":"3. Vector Computation and Vector Stores","text":"<p>Data is transformed into vectors using OpenAI or custom models. Understanding where to run these models and integrating your computing infrastructure with tools like custom spark pipelines is essential. The aim is to achieve ready-to-use pipelines and models.</p> <p></p> Vector Stores  <p>Image Source</p>"},{"location":"rags/#4-graph-computation-and-graph-stores","title":"4. Graph Computation and Graph Stores","text":"<p>Creating a knowledge graph from your data allows for querying and information retrieval. It's essential to know how to construct, maintain, and use it for text generation. The aim is an accurate, current, and easily queried knowledge graph.</p> <p></p> Graph Example"},{"location":"rags/#5-search","title":"5. Search","text":"<p>The process involves querying and retrieving vectors from Vector DBs or hybrid DBs, and using search tools to rank these vectors. The aim is to index vectors and search for relevant ones as needed.</p>"},{"location":"rags/#vector-similarity-search","title":"Vector Similarity Search","text":"<p>Identifies objects with vector representations closest to the query vector, finding the most similar items based on various dimensions of comparison.</p>"},{"location":"rags/#image-search","title":"Image Search","text":"<p>Utilizes images as the input for conducting a similarity search, analyzing the content of the image to find similar images based on visual features.</p>"},{"location":"rags/#keyword-search","title":"Keyword Search","text":"<p>Employs the BM25F algorithm for ranking results based on keyword matches. Relevance is calculated using term frequency, inverse document frequency, and field-length normalization.</p>"},{"location":"rags/#hybrid-search","title":"Hybrid Search","text":"<p>Merges the BM25 algorithm with vector similarity search techniques to enhance the relevance and accuracy of search results. Leverages both textual and vector-based features for ranking.</p>"},{"location":"rags/#generative-search","title":"Generative Search","text":"<p>Utilizes the outputs of search results as prompts for a Large Language Model (LLM). Can generate summaries, extrapolations, or new content based on the aggregated search results.</p>"},{"location":"rags/#reranking","title":"Reranking","text":"<p>Involves the application of a reranker module to adjust the initial ranking of search results. Optimizes result relevance based on additional criteria or more complex models.</p>"},{"location":"rags/#aggregation","title":"Aggregation","text":"<p>Involves compiling and summarizing data from a set of search results. Provides insights or overviews based on the collective information found.</p>"},{"location":"rags/#filters","title":"Filters","text":"<p>Apply constraints or conditions to the search process to narrow down the results. Filters can be based on specific attributes, metadata, or other criteria relevant to the search domain.</p>"},{"location":"rags/#graph-search","title":"Graph Search","text":"<p>Involves traversing a graph data structure to find specific nodes or paths. It can be used to find relationships between different entities in a knowledge graph.</p>"},{"location":"research/","title":"Research","text":"<p>The page is dedicated to collecting all research that was collected in the past one year from various sources.</p> <p>This is not an exhaustive list, and any PRs would be welcome</p>"},{"location":"research/#research-papers","title":"Research Papers","text":"<ul> <li>[2024/06/04] Symbolic reasoning</li> <li>[2024/06/04] Transformers and episodic memory</li> <li>[2024/03/24] Graph Chain-of-Thought: Augmenting Large Language Models by Reasoning on Graphs</li> <li>[2024/03/24] Leave No Context Behind: Efficient Infinite Context Transformers with Infini-attention</li> <li>[2024/03/24] Compound AI systems</li> <li>[2015/07/30] Multilayer Network of Language</li> <li>[2023/12/12]  Dense X Retrieval: What Retrieval Granularity Should We Use?</li> <li>[2024/01/05] Retrieval-Augmented Generation for Large Language Models: A Survey</li> <li>[2022/10/20]  Cognitive modelling with multilayer networks: Insights, advancements and future challenges</li> <li>[2023/09/20] CoAla framework and relevant literature literature</li> <li>[2023/06/09]\u00a0Mind2Web: Towards a Generalist Agent for the Web, Xiang Deng, et al.\u00a0[code] [demo]</li> <li>[2023/06/28] AI Agents in Langchain https://docs.google.com/presentation/d/1L_CHsg26sDxPmKj285Ob5T2xsAUejBlfiGQSnsSHTk0/edit#slide=id.g254e571859c_0_164</li> <li>[2023/06/27] Agent infra https://lilianweng.github.io/posts/2023-06-23-agent/</li> <li>[2023/06/05]\u00a0Orca: Progressive Learning from Complex Explanation Traces of GPT-4, Subhabrata Mukherjee et al.</li> <li>[2023/05/25]\u00a0\ud83d\udcdaVoyager: An Open-Ended Embodied Agent with Large Language Models, Guanzhi Wang, et al.\u00a0[code] [website], Shishir G. Patil, et al.</li> <li>[2023/05/24]\u00a0\ud83d\udcdaGorilla: Gorilla: Large Language Model Connected with Massive APIs</li> <li>[2023/05/17]\u00a0\ud83d\udcdaTree of Thoughts: Deliberate Problem Solving with Large Language Models, Shunyu Yao, et al.[code] [code-orig]</li> <li>[2023/05/12]\u00a0\ud83d\udcdaMEGABYTE: Predicting Million-byte Sequences with Multiscale Transformers, Lili Yu, et al.</li> <li>[2023/05/09]\u00a0\ud83d\udcdaFrugalGPT: How to Use Large Language Models While Reducing Cost and Improving Performance, Lingjiao Chen, et al.</li> <li>[2023/05/01]\u00a0\ud83d\udcdaLearning to Reason and Memorize with Self-Notes, Jack Lanchantin, et al.</li> <li>[2023/04/24]\u00a0\ud83d\udcdaWizardLM: Empowering Large Language Models to Follow Complex Instructions, Can Xu, et al.</li> <li>[2023/04/22]\u00a0\ud83d\udcdaLLM+P: Empowering Large Language Models with Optimal Planning Proficiency, Bo Liu, et al.</li> <li>[2023/04/07]\u00a0\ud83d\udcdaGenerative Agents: Interactive Simulacra of Human Behavior, Joon Sung Park, et al.\u00a0[code]</li> <li>[2023/03/30]\u00a0Self-Refine: Iterative Refinement with Self-Feedback, Aman Madaan, et al.[code]</li> <li>[2023/03/30]\u00a0HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HuggingFace, Yongliang Shen, et al.\u00a0[code] [demo]</li> <li>[2023/03/20]\u00a0Reflexion: Language Agents with Verbal Reinforcement Learning, Noah Shinn , et al.\u00a0[code]</li> <li>[2023/02/23]\u00a0\ud83d\udcdaNot what you've signed up for: Compromising Real-World LLM-Integrated Applications with Indirect Prompt Injection, Sahar Abdelnab, et al.</li> <li>[2023/02/09]\u00a0\ud83d\udcdaToolformer: Language Models Can Teach Themselves to Use Tools, Timo Schick, et al.\u00a0[code]</li> <li>[2022/12/12]\u00a0\ud83d\udcdaLMQL: Prompting Is Programming: A Query Language for Large Language Models, Luca Beurer-Kellner, et al.</li> <li>[2022/10/06]\u00a0ReAct: Synergizing Reasoning and Acting in Language Models, Shunyu Yao, et al.\u00a0[code]</li> <li>[2022/07/12]\u00a0\ud83d\udcdaInner Monologue: Embodied Reasoning through Planning with Language Models, Wenlong Huang, et al.\u00a0[demo]</li> <li>[2022/04/04]\u00a0Do As I Can, Not As I Say: Grounding Language in Robotic Affordances, Michael Ahn, e al.\u00a0[demo]</li> <li>[2021/12/17]\u00a0WebGPT: Browser-assisted question-answering with human feedback, Reiichiro Nakano, et al.</li> <li>[2021/06/17]\u00a0\ud83d\udcdaLoRA: Low-Rank Adaptation of Large Language Models, Edward J. Hu, et al.</li> <li>[2023/04/03] Generative Agents</li> <li>[2023/05/17] Three of thought: Deliberate Problem Solving with Large Language Models</li> </ul>"},{"location":"research/#knowledge-graphs","title":"Knowledge Graphs","text":"<ul> <li>[2023/06/09]\u00a0Taxonomies: Overview</li> </ul>"},{"location":"research/#blog-articles","title":"Blog Articles","text":"<ul> <li>[2023/04/29]\u00a0AUTO-GPT: UNLEASHING THE POWER OF AUTONOMOUS AI AGENTS\u00a0By Akash Takyar</li> <li>[2023/04/20]\u00a0Conscious Machines: Experiments, Theory, and Implementations(Chinese)\u00a0By Jiang Zhang</li> <li>[2023/04/18]\u00a0Autonomous Agents &amp; Agent Simulations\u00a0By Langchain</li> <li>[2023/04/16]\u00a04 Autonomous AI Agents you need to know\u00a0By Sophia Yang</li> <li>[2023/03/31]\u00a0ChatGPT that learns to use tools\u00a0By Haojie Pan</li> </ul>"},{"location":"research/#talks","title":"Talks","text":"<ul> <li>[2023/06/05]\u00a0Two Paths to Intelligence\u00a0by Geoffrey Hinton</li> <li>[2023/05/24]\u00a0State of GPT\u00a0by Andrej Karpathy | OpenAI</li> <li>[2024/03/15] Podcast on AI, Memory by Bill Gurley</li> </ul>"},{"location":"search/","title":"Explore data","text":""},{"location":"search/#cognee-search-module","title":"Cognee Search Module","text":"<p>This module contains the search function that is used to search for nodes in the graph. It supports various search types and integrates with user permissions to filter results accordingly.</p>"},{"location":"search/#search-types","title":"Search Types","text":"<p>The <code>SearchType</code> enum defines the different types of searches that can be performed:</p> <ul> <li><code>ADJACENT</code>: Search for nodes adjacent to a given node.</li> <li><code>TRAVERSE</code>: Traverse the graph to find related nodes.</li> <li><code>SIMILARITY</code>: Find nodes similar to a given node.</li> <li><code>SUMMARY</code>: Retrieve a summary of the node.</li> <li><code>SUMMARY_CLASSIFICATION</code>: Classify the summary of the node.</li> <li><code>NODE_CLASSIFICATION</code>: Classify the node.</li> <li><code>DOCUMENT_CLASSIFICATION</code>: Classify the document.</li> <li><code>CYPHER</code>: Perform a Cypher query on the graph.</li> </ul>"},{"location":"search/#search-parameters","title":"Search Parameters","text":"<p>The <code>SearchParameters</code> class is a Pydantic model that validates and holds the search parameters:</p> <pre><code>class SearchParameters(BaseModel):\n    search_type: SearchType\n    params: Dict[str, Any]\n\n    @field_validator(\"search_type\", mode=\"before\")\n    def convert_string_to_enum(cls, value):\n        if isinstance(value, str):\n            return SearchType.from_str(value)\n        return value\n</code></pre>"},{"location":"search/#search-function","title":"Search Function","text":"<p>The <code>search</code> function is the main entry point for performing a search. It handles user authentication, retrieves document IDs for the user, and filters the search results based on user permissions.</p> <pre><code>async def search(search_type: str, params: Dict[str, Any], user: User = None) -&gt; List:\n    if user is None:\n        user = await get_default_user()\n\n    own_document_ids = await get_document_ids_for_user(user.id)\n    search_params = SearchParameters(search_type=search_type, params=params)\n    search_results = await specific_search([search_params])\n\n    from uuid import UUID\n\n    filtered_search_results = []\n\n    for search_result in search_results:\n        document_id = search_result[\"document_id\"] if \"document_id\" in search_result else None\n        document_id = UUID(document_id) if type(document_id) == str else document_id\n\n        if document_id is None or document_id in own_document_ids:\n            filtered_search_results.append(search_result)\n\n    return filtered_search_results\n</code></pre>"},{"location":"team/","title":"Team","text":""},{"location":"templates/","title":"TASKS","text":"<p>cognee uses tasks grouped into pipelines to populate graph and vector stores</p> <p>Cognee uses tasks grouped into pipelines to populate graph and vector stores. These tasks are designed to analyze and enrich your data, improving the answers generated by Large Language Models (LLMs).</p> <p>In this section, you'll find a template that you can use to structure your data and build pipelines.  These tasks are designed to help you get started with cognee and build reliable LLM pipelines</p>"},{"location":"templates/#task-1-category-extraction","title":"Task 1: Category Extraction","text":"<p>Data enrichment is the process of enhancing raw data with additional information to make it more valuable. This template is a sample task that extract categories from a document and populates a graph with the extracted categories.</p> <p>Let's go over the steps to use this template full code provided here:</p> <p>This function is designed to classify chunks of text using a specified language model. The goal is to categorize the text, map relationships, and store the results in a vector engine and a graph engine. The function is asynchronous, allowing for concurrent execution of tasks like classification and data point creation.</p>"},{"location":"templates/#parameters","title":"Parameters","text":"<ul> <li><code>data_chunks: list[DocumentChunk]</code>: A list of text chunks to be classified. Each chunk represents a piece of text and includes metadata like <code>chunk_id</code> and <code>document_id</code>.</li> <li><code>classification_model: Type[BaseModel]</code>: The model used to classify each chunk of text. This model is expected to output labels that categorize the text.</li> </ul>"},{"location":"templates/#steps-in-the-function","title":"Steps in the Function","text":""},{"location":"templates/#check-for-empty-input","title":"Check for Empty Input","text":"<pre><code>if len(data_chunks) == 0:\n    return data_chunks\n</code></pre> <p>If there are no data chunks provided, the function returns immediately with the input list (which is empty).</p>"},{"location":"templates/#classify-each-chunk","title":"Classify Each Chunk","text":"<pre><code>chunk_classifications = await asyncio.gather(\n    *[extract_categories(chunk.text, classification_model) for chunk in data_chunks],\n)\n</code></pre> <p>The function uses <code>asyncio.gather</code> to concurrently classify each chunk of text. <code>extract_categories</code> is called for each chunk, and the results are collected in <code>chunk_classifications</code>.</p>"},{"location":"templates/#initialize-data-structures","title":"Initialize Data Structures","text":"<pre><code>classification_data_points = []\n</code></pre> <p>A list is initialized to store the classification data points that will be used later for mapping relationships and storing in the vector engine.</p>"},{"location":"templates/#generate-uuids-for-classifications","title":"Generate UUIDs for Classifications","text":"<p>The function loops through each chunk and generates unique identifiers (UUIDs) for both the main classification type and its subclasses:</p> <pre><code>classification_data_points.append(uuid5(NAMESPACE_OID, chunk_classification.label.type))\nclassification_data_points.append(uuid5(NAMESPACE_OID, classification_subclass.value))\n</code></pre> <p>These UUIDs are used to uniquely identify classifications and ensure consistency.</p>"},{"location":"templates/#retrieve-or-create-vector-collection","title":"Retrieve or Create Vector Collection","text":"<pre><code>vector_engine = get_vector_engine()\ncollection_name = \"classification\"\n</code></pre> <p>The function interacts with a vector engine. It checks if the collection named \"classification\" exists. If it does, it retrieves existing data points to avoid duplicates. Otherwise, it creates the collection.</p>"},{"location":"templates/#prepare-data-points-nodes-and-edges","title":"Prepare Data Points, Nodes, and Edges","text":"<p>The function then builds a list of <code>data_points</code> (representing the classification results) and constructs nodes and edges to represent relationships between chunks and their classifications:</p> <pre><code>data_points.append(DataPoint[Keyword](...))\nnodes.append((...))\nedges.append((...))\n</code></pre> <ul> <li>Nodes: Represent classifications (e.g., media type, subtype).</li> <li>Edges: Represent relationships between chunks and classifications (e.g., \"is_media_type\", \"is_subtype_of\").</li> </ul>"},{"location":"templates/#create-data-points-and-relationships","title":"Create Data Points and Relationships","text":"<p>If there are new nodes or edges to add, the function stores the data points in the vector engine and updates the graph engine with the new nodes and edges:</p> <pre><code>await vector_engine.create_data_points(collection_name, data_points)\nawait graph_engine.add_nodes(nodes)\nawait graph_engine.add_edges(edges)\n</code></pre>"},{"location":"templates/#return-the-processed-chunks","title":"Return the Processed Chunks","text":"<p>Finally, the function returns the processed <code>data_chunks</code>, which can now be used further as needed:</p> <pre><code>return data_chunks\n</code></pre>"},{"location":"templates/#pipeline-1-cognee-pipeline","title":"Pipeline 1: cognee pipeline","text":"<p>This is the main pipeline currently implemented in cognee. It is designed to process data in a structured way and populate the graph and vector stores with the results</p> <p>This function is the entry point for processing datasets. It handles dataset retrieval, user authorization, and manages the execution of a pipeline of tasks that process documents.</p>"},{"location":"templates/#parameters_1","title":"Parameters","text":"<ul> <li><code>datasets: Union[str, list[str]] = None</code>: A string or list of dataset names to be processed.</li> <li><code>user: User = None</code>: The user requesting the processing. If not provided, the default user is retrieved.</li> </ul>"},{"location":"templates/#steps-in-the-function_1","title":"Steps in the Function","text":""},{"location":"templates/#database-engine-initialization","title":"Database Engine Initialization","text":"<pre><code>db_engine = get_relational_engine()\n</code></pre> <p>The function starts by getting an instance of the relational database engine, which is used to retrieve datasets and other necessary data.</p>"},{"location":"templates/#handle-empty-or-string-dataset-input","title":"Handle Empty or String Dataset Input","text":"<pre><code>if datasets is None or len(datasets) == 0:\n    return await cognify(await db_engine.get_datasets())\nif type(datasets[0]) == str:\n    datasets = await retrieve_datasets(datasets)\n</code></pre> <p>If no datasets are provided, the function retrieves all available datasets from the database. If a list of dataset names (strings) is provided, they are converted into dataset objects.</p>"},{"location":"templates/#user-authentication","title":"User Authentication","text":"<pre><code>if user is None:\n    user = await get_default_user()\n</code></pre> <p>If no user is provided, the function retrieves the default user.</p>"},{"location":"templates/#run-cognify-pipeline-for-each-dataset","title":"Run Cognify Pipeline for Each Dataset","text":"<pre><code>async def run_cognify_pipeline(dataset: Dataset):\n    # Pipeline logic goes here...\n</code></pre> <p>The <code>run_cognify_pipeline</code> function is defined within <code>cognify</code> and is responsible for processing a single dataset. This is where most of the heavy lifting occurs.</p>"},{"location":"templates/#retrieve-dataset-data","title":"Retrieve Dataset Data","text":"<p>The function fetches all the data associated with the dataset.</p> <pre><code>data: list[Data] = await get_dataset_data(dataset_id=dataset.id)\n</code></pre>"},{"location":"templates/#create-document-objects","title":"Create Document Objects","text":"<p>Based on the file type (e.g., PDF, Audio, Image, Text), corresponding document objects are created.</p> <pre><code>documents = [...]\n</code></pre>"},{"location":"templates/#check-permissions","title":"Check Permissions","text":"<p>The user's permissions are checked to ensure they can access the documents.</p> <pre><code>await check_permissions_on_documents(user, \"read\", document_ids)\n</code></pre>"},{"location":"templates/#pipeline-status-logging","title":"Pipeline Status Logging","text":"<p>The function logs the start and end of the pipeline processing.</p> <pre><code>async with update_status_lock:\n    task_status = await get_pipeline_status([dataset_id])\n    if dataset_id in task_status and task_status[dataset_id] == \"DATASET_PROCESSING_STARTED\":\n        logger.info(\"Dataset %s is already being processed.\", dataset_name)\n        return\n    await log_pipeline_status(dataset_id, \"DATASET_PROCESSING_STARTED\", {...})\n</code></pre>"},{"location":"templates/#pipeline-tasks","title":"Pipeline Tasks","text":"<p>The pipeline consists of several tasks, each responsible for different parts of the processing:</p> <ul> <li><code>document_to_ontology</code>: Maps documents to an ontology structure.</li> <li><code>source_documents_to_chunks</code>: Splits documents into chunks.</li> <li><code>chunk_to_graph_decomposition</code>: Defines the graph structure for chunks.</li> <li><code>chunks_into_graph</code>: Integrates chunks into the knowledge graph.</li> <li><code>chunk_update_check</code>: Checks for updated or new chunks.</li> <li><code>save_chunks_to_store</code>: Saves chunks to a vector store and graph database.</li> </ul> <p>Parallel Tasks: <code>chunk_extract_summary</code> and <code>chunk_naive_llm_classifier</code> run in parallel to summarize and classify chunks.</p> <ul> <li><code>chunk_remove_disconnected</code>: Cleans up obsolete chunks.</li> </ul> <p>The tasks are managed and executed asynchronously using the <code>run_tasks</code> and <code>run_tasks_parallel</code> functions.</p> <pre><code>pipeline = run_tasks(tasks, documents)\nasync for result in pipeline:\n    print(result)\n</code></pre>"},{"location":"templates/#handle-errors","title":"Handle Errors","text":"<p>If any errors occur during processing, they are logged, and the exception is raised.</p> <pre><code>except Exception as error:\n    await log_pipeline_status(dataset_id, \"DATASET_PROCESSING_ERROR\", {...})\n    raise error\n</code></pre>"},{"location":"templates/#processing-multiple-datasets","title":"Processing Multiple Datasets","text":"<p>The function prepares to process multiple datasets concurrently using <code>asyncio.gather</code>.</p> <pre><code>awaitables = []\nfor dataset in datasets:\n    dataset_name = generate_dataset_name(dataset.name)\n    if dataset_name in existing_datasets:\n        awaitables.append(run_cognify_pipeline(dataset))\nreturn await asyncio.gather(*awaitables)\n</code></pre>"},{"location":"why/","title":"Why use cognee?","text":"<p>cognee is one of the first OSS tools that enables easy, scalable and flexible use of LLMs to process large volumes of documents using GraphRAG approach. </p> <p>LLMs don't have a semantic layer, and they don't have a way to understand the data they are processing. This is where cognee comes in.  We let you define logical structures for your data and then use these structures to guide the LLMs to process the data in a way that makes sense to you.</p> <p>cognee helps you avoid the overly complicated set of tools and processes to give you somewhat reliable output</p> <p>From</p> <p></p> <p>To</p> <p></p> Why use cognee? <p>Its hard to answer the question of why use cognee without answering why you need thin LLM frameworks in the first place.:)</p> <ul> <li>Cost-effective \u2014 cognee extends the capabilities of your LLMs without the need for expensive data processing tools.</li> <li>Self-contained \u2014 cognee runs as a simple-to-use library meaning you can add it to your application easily</li> <li>Easy to use \u2014 Navigate graphs instead of embeddings to understand your data faster and better</li> <li>Flexible \u2014 cognee lets you control your input and provide your own Pydantic data models.</li> </ul>"},{"location":"blog/","title":"Blog","text":"<p>The goal of the blog is to discuss broader topics around the cognee project, including the motivation behind the project, the technical details, and the future of the project.</p>"},{"location":"blog/#knowledge-graphs-rags","title":"knowledge graphs + rags","text":"<ol> <li>LLMOps stack + Graphs</li> </ol>"},{"location":"blog/#product-announcements","title":"product announcements","text":"<p>This section covers the release notes for the cognee library. It includes the new features, bug fixes, and improvements in each release.</p> <ol> <li> <p>Cognee - library release</p> </li> <li> <p>New website for cognee</p> </li> </ol>"},{"location":"blog/#towards-deterministic-data-pipelines-for-llms-step-by-step","title":"Towards deterministic data pipelines for LLMs step by step","text":"<p>This series mostly deals with product discovery, data engineering, and the development of robust AI memory data pipelines.</p> <ol> <li>From demo to production 1</li> <li>From demo to production 2</li> <li>From demo to production 3</li> <li>From demo to production 4</li> </ol>"},{"location":"blog/2024/06/14/llmops-stack--graphs/","title":"LLMOps stack + Graphs","text":"","tags":["LLMOps","Graphs","Vector Stores","Feature Storage"]},{"location":"blog/2024/06/14/llmops-stack--graphs/#the-past-berlin-startup-scene","title":"The past: Berlin startup scene","text":"<p>Machine learning has had its place in the business models of companies for several years, but due to high labor costs, lack of generalizability, and long development cycles, it often did not meet the early days' expectations. With the rise of ChatGPT, however, foundation models and LLMs are reemerging as the next step in the evolution in the Machine Learning stack, democratizing it for the end users.</p> <p>As a consultant and operator in the Berlin startup scene over the past ten years, I have seen the vocation of \u201cData Scientist\u201d reflect this trend as well. Its initial popularity, decline, and resurgence easily could have mirrored the rise and fall of the Roman Empire. Humble beginnings, grandiosity, and then the rigidity of thought of early Christianity. </p> <p>In my early years as a data analyst in tier-II e-commerce businesses, data science was considered a prestigious, cutting-edge title. However,\u00a0 most of these ventures lacked the experience or maturity to properly productionize their business models.</p> <p>Often, I would see a data scientist building tons of features for their company\u2019s AI models to only slightly improve on their basic KPIs. They were often stuck in the limbo of demoware, and only the businesses in which data was a key operational element would successfully deploy and run data science systems at scale.</p>","tags":["LLMOps","Graphs","Vector Stores","Feature Storage"]},{"location":"blog/2024/06/14/llmops-stack--graphs/#pandemic-and-fall-out-of-grace","title":"Pandemic and fall out of grace","text":"<p>Over the years, this low impact-high drain dynamic led to data science falling out of favor. The COVID pandemic seemed to deliver a death blow to the Berlin Data Science community, with many data scientists being made redundant.</p> <p>This played out differently in larger markets and companies, where I saw more mature setups heavily relying on machine learning. However, from the perspective of most software Mittelstand (a German term for medium-sized enterprises), the technology was seen as a nice-to-have, not a must-have.</p> <p>Suddenly, with the release of ChatGPT, most knowledge previously required to operate machine learning became obsolete,\u00a0 with the only thing now needed being an API key. This dropped the barrier to entry to the floor and created a need for new tools to be built around these APIs.</p> <p>Tools like Langchain met this need perfectly, enabling everyone to interact with their data.</p>","tags":["LLMOps","Graphs","Vector Stores","Feature Storage"]},{"location":"blog/2024/06/14/llmops-stack--graphs/#ml-to-llmops","title":"ML to LLMOps","text":"<p>A question arises about how we should approach LLM tooling. Ignoring previous knowledge and inferring new paradigms(Agents come to mind)\u00a0 as if in a vacuum can be counterproductive. Re-inventing categories should be done cautiously; history shows that overdoing it can lead to failure.</p> <p>A recently published article by angel investor and Professor of Neuroscience at U.C. London, Peter Zhegin, has effectively mapped out the elements of the MLOps system ripe for disruption, suggesting which ones might be impacted:</p> <ol> <li>Vector Stores: The authors argue that data storage and vector stores will be acquired by large players, but that differentiation still may be possible in the data space. They state that \"A realistic way to differentiate might be to push for real-time vectorization while finding the best way to use traditional databases and feature stores (relational/NoSQL) together with vector DBs.\"</li> <li>Feature Storage: The authors note that \"Prompt engineering does not involve traditional training but allows one to change the model's behavior during inference by creating appropriate instructions or queries. This \u2018training without training\u2019 presents an interesting opportunity outside the MLOps pipeline.\"</li> </ol>","tags":["LLMOps","Graphs","Vector Stores","Feature Storage"]},{"location":"blog/2024/06/14/llmops-stack--graphs/#feature-stores-and-the-next-steps","title":"Feature Stores and the Next Steps","text":"<p>The evolution of the MLOps stack signals a need for a new type of feature store that enables in-context learning.</p> <p>Since fine-tuning LLMs will start happening at inference time, we need a system to interact with and manage data points fed to the LLM at scale. This implies a need for a feature store that provides more determinism to the LLM outputs, enabling the integration of business processes and practices into data that captures the context of an enterprise or organization.</p> <p>An example of such a use case would be using a set of documents from different departments, enabling the LLM to understand the relationships between these documents and their individual parts.</p> <p>This effort often requires humans to provide the base rules for how the LLM should interact with the information, leading to the creation of what is commonly referred to as a RAG (Retrieval Augmented Generation) pipeline.</p> <p>Since recently, we\u2019ve been able to combine graphs and vector data stores to create a semantic layer on top of naive RAGs. This layer has been a major step towards encoding rules into an in-context learning pipeline.</p> <p>In his recent blog post, co-founder of WhyHow.AI, Chia Jeng Yang, explained what a typical RAG pipeline looks like. He also introduced Graph Ops and Vector Ops as new elements of the RAG stack which can lead to more stable retrieval patterns.</p> <p></p> <p>The argument Zhegin made a few months ago is now taking shape. We are seeing feature stores evolve into tools that manage vector and graph stores.</p> <p>We are still in the early stages, though. As Jon Turrow of Madrona Ventures\u00a0 suggests, the next generation of AI agent infrastructure\u2014what Chia refers to as Graph Ops\u2014will be a personalization layer.</p> <p>I believe that these terms are interchangeable and that a new in-context Feature Store, Vector and Graph Ops, and personalization layers are essentially the same thing. Moreover, it\u2019s my belief that Vector and Graph Ops are not differentiation categories in and of themselves.</p> <p>The challenge is, thus, not connecting Vector and Graph stores or giving a RAG system a 10% performance boost.</p> <p>The main issues still remain </p> <p>The challenge and solution lie in creating a new type of probabilistic data engine\u2014one with an interface as simple as SQL, but which can retrieve and structure information in real-time, optimizing what we feed the LLM based on solid evaluations.</p> <p>Striving to make sense of the best computing engine we know of\u2014our mind\u2014cognitive sciences may offer us clues on how to move forward.</p> <p>After all, we process, store, and retrieve data from our mental lexicon with ease, with inherent personalization and dynamic data enrichment.</p> <p>I believe that understanding the way our mind carries out these processes may allow us to replicate them in machine learning.</p> <p>With human language as the new SQL and cognitive theories as inspiration, the next generation of tooling is still on the horizon.</p>","tags":["LLMOps","Graphs","Vector Stores","Feature Storage"]},{"location":"blog/2024/04/02/cognee----release-v010/","title":"Cognee -  release v0.1.0","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#preface","title":"Preface","text":"<p>In a series of posts we explored issues with RAGs and the way we can build new infrastructure stack for the world of agent networks.</p> <p>To borrow the phrase Microsoft used, to restate the problem: </p> <ul> <li>Baseline RAG performs poorly when asked to understand summarized semantic concepts holistically over large data collections or even singular large documents.</li> </ul> <p>In the previous blog post we explained how developing a data platform and a memory layer for LLMs was one of our core aims.</p> <p>To do that more effectively we turned cognee into a python library in order to make it easier to use and get inspiration from the OSS community. </p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#improved-memory-architecture","title":"Improved memory architecture","text":"<p>With the integration of Keepi.ai, we encountered several challenges that made us reassess our strategy. Among the issues we\u2019ve identified were:</p> <ul> <li> <p>The decomposition of user prompts into interconnected elements proved overly granular, leading to data management difficulties on load and retrieval.</p> </li> <li> <p>A recurring problem was the near-identical decomposition pattern for similar messages, which resulted in content duplication and an enlarged user graph. Our takeaway was that words and their interrelations represent only a fragment of the broader picture. We need to be able to guide the set of logical connections and make the system dynamic so that the data models can be adapted and adjusted to each particular use-case. What works for e-commerce transaction handling might not work for an AI vertical creating power point slides.</p> </li> <li> <p>The data model, encompassing Long-Term, Short-Term, and Buffer memory, proved both limited in scope and rigid, lacking the versatility to accommodate diverse applications and use cases. Just collecting all elements from all memories seemed naive, while getting certain nodes with classifiers did not add enough value.</p> </li> <li> <p>The retrieval of the entire buffer highlighted the need for improved buffer content management and a more adaptable buffer structure. We conceptualized the buffer as the analogue of human working memory, and recognize the need to better manage the stored data.</p> </li> </ul> <p>Moving forward, we have adopted several new strategies, features, and design principles:</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#propositions","title":"Propositions:","text":"<p>Defined as atomic expressions within a text, each proposition encapsulates a unique factoid, conveyed in a succinct, standalone natural language format. We employ Large Language Models (LLMs) to break down text into propositions and link them, forming graphs with propositions as nodes and their connections as edges.  For example,  \"Grass is green\", and \"2 + 5 = 5\"  are propositions. The first proposition has the truth value of \"true\" and the second \"false\".  The inspiration was found in the following paper: https://arxiv.org/pdf/2312.06648.pdf</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#multilayer-graph-network","title":"Multilayer Graph Network:","text":"<p>A cognitive multilayer networks is both a quantitative and interpretive framework for exploring the mental lexicon, the intricate cognitive system that stores information about known words/concepts.</p> <p>Mental lexicon is component of the human language faculty that contains information regarding the composition of words.</p> <p>Utilizing LLMs, we construct layers within the multilayer network to house propositions and their interrelations, enabling the interconnection of different semantic layers and the cross-layer linking of propositions. This facilitates both the segmentation and accurate retrieval of information.</p> <p>For example, if \"John Doe\" authored two New York Times cooking articles, we could extract an \"ingredients\" layer when needed, while also easily accessing all articles by \"John Doe\".</p> <p>We used concepts from psycholinguistics described here: https://arxiv.org/abs/1507.08539</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#data-loader","title":"Data Loader:","text":"<p>It\u2019s vital that we address the technical challenges associated with Retrieval-Augmented Generation (RAG), such as metadata management, context retrieval, knowledge sanitization, and data enrichment.</p> <p>The solution lies in a dependable data pipeline capable of efficiently and scalably preparing and loading data in various formats from a range of different sources. For this purpose, we can use 'dlt' as our data loader, gaining access to over 28 supported data sources.</p> <p>To enhance the Pythonic interface, we streamlined the use of cognee into three primary methods. Users can now execute the following steps:</p> <ul> <li>cognee.add(data): This method is used to input and normalize the data. It ensures the data is in the correct format and ready for further processing.</li> <li>cognee.cognify(): This function constructs a multilayer network of propositions, organizing the data into an interconnected, semantic structure that facilitates complex analysis and retrieval.</li> <li>cognee.search(query, method='default'): The search method enables the user to locate specific nodes, vectors, or generate summaries within the dataset, based on the provided query and chosen search method. We employ a combination of search approaches, each one relying on the technology implemented by vector datastores and graph stores.</li> </ul>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#integration-and-workflow","title":"Integration and Workflow","text":"<p>The integration of these three components allows for a cohesive and efficient workflow:</p> <p>Data Input and Normalization: </p> <p>Initially, Cognee.add is employed to input the data. During this stage, a dlt loader operates behind the scenes to process and store the data, assigning a unique dataset ID for tracking and retrieval purposes. This ensures the data is properly formatted and normalized, laying a solid foundation for the subsequent steps.</p> <p>Creation of Multilayer Network: </p> <p>Following the data normalization, Cognee.cognify takes the stage, constructing a multilayer network from the propositions derived from the input data. The network is created using LLM as a judge approach, with specific prompt that ask for creating of a set of relationships. This approach results in a set of layers and relationships that represent the document. </p> <p>Data Retrieval and Analysis</p> <p>The final step involves Cognee.search, where the user can query the constructed network to find specific information, analyze patterns, or extract summaries. The flexibility of the search function allows to search for content labels, summaries, nodes and also be able to retrieve data via similarity search. We also enable a combination of methods, which leads to getting benefits of different search approaches. </p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/04/02/cognee----release-v010/#whats-next","title":"What\u2019s next","text":"<p>We're diligently developing our upcoming features, with key objectives including:</p> <ol> <li>Adding audio and image support</li> <li>Improving search</li> <li>Adding evals</li> <li>Adding local models</li> <li>Adding dspy</li> </ol> <p>To keep up with the progress, explore our implementation on GitHub and, if you find it valuable, consider starring it to show your support.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/06/14/cognee-new-website/","title":"Cognee new website","text":"<p>We are excited to announce the launch of Cognee.ai.</p> <p>Highlights: Book a Discussion: Schedule a consultation directly through our website. Check it out at: www.cognee.ai and book your discussion with our experts.</p> <p>We'd be happy to hear your feedback and discuss GraphRAGs, and more.</p>","tags":["graphs","GraphRAG"]},{"location":"blog/2024/05/08/cognee-v014/","title":"Cognee v0.1.4","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#cognee-release-v014","title":"Cognee - release v0.1.4","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#new-features","title":"New Features","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#enhanced-text-processing-capabilities","title":"Enhanced Text Processing Capabilities:","text":"<p>Customizable models for classification, summarization, and labeling have been introduced to extend the versatility of our text analytics.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#better-graph-integration-and-visualization","title":"Better Graph Integration and Visualization:","text":"<p>We have revamped our graph logic. Introduced comprehensive support for multiple graph database types including but not limited to Neo4j and NetworkX, enhancing integration and scalability.  New functions for graph rendering, color palette generation, and dynamic graph visualization to help you better visualize data relationships and structures.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#dspy-module","title":"DSPy Module:","text":"<p>You can now train your graph generation query on a dataset and visualize the results with the dspy module. </p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#async-support","title":"Async Support:","text":"<p>Added asyncio support in various modules to improve performance and system efficiency, reducing latency and resource consumption.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#enhancements","title":"Enhancements","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#infrastructure-upgrades","title":"Infrastructure Upgrades:","text":"<p>Our infrastructure has been significantly upgraded to support a wider range of models and third-party providers, ensuring compatibility and performance. Improved configuration settings for a more robust and adaptive operational environment.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#graph-and-logic-improvements","title":"Graph and Logic Improvements:","text":"<p>Improved Neo4j Integration: Enhancements to our Neo4j graph database integration for better performance and stability. Semantic Links and Node Logic: We have improved the semantic linkage between nodes and enhanced the node logic for a more intuitive and powerful user experience.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#refactor","title":"Refactor","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#asynchronous-module-updates","title":"Asynchronous Module Updates:","text":"<p>Various modules have been updated to use asynchronous operations to enhance the responsiveness and scalability of our systems.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#documentation","title":"Documentation","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#enhanced-documentation","title":"Enhanced Documentation:","text":"<p>We have extensively added to and reorganized our documentation.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#bug-fixes","title":"Bug Fixes","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2024/05/08/cognee-v014/#data-handling-and-logic-improvements","title":"Data Handling and Logic Improvements:","text":"<p>Fixed several inconsistencies in data handling and  improved the logic flow in text input processing.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/","title":"Going beyond Langchain + Weaviate and towards a production ready modern data platform","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#table-of-contents","title":"Table of Contents","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#1-introduction-the-current-generative-ai-landscape","title":"1. Introduction: The Current Generative AI Landscape","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#11-a-brief-overview","title":"1.1. A brief overview","text":"<p>Browsing the largest AI platform directory available at the moment, we can observe around 7,000 new, mostly semi-finished AI projects \u2014 projects whose development is fueled by recent improvements in foundation models and open-source community contributions.</p> <p>Decades of technological advancements have led to small teams being able to do in 2023 what in 2015 required a team of dozens.</p> <p>Yet, the AI apps currently being pushed out still mostly feel and perform like demos.</p> <p>It seems it has never been easier to create a startup, build an AI app, go to market\u2026 and fail.</p> <p>The consensus is, nevertheless, that the AI space is the place to be in 2023.</p> <p>\u201cThe AI Engineer [...] will likely be the highest-demand engineering job of the [coming] decade.\u201d </p> <p>Swyx</p> <p>The stellar rise of AI engineering as a profession is, perhaps, signaling the need for a unified solution that is not yet there \u2014 a platform that is, in its essence, a Large Language Model (LLM), which could be employed as a powerful general problem solver.</p> <p>To address this issue, dlthub and prometh.ai will collaborate on productionizing a common use-case, PDF processing, progressing step by step. We will use LLMs, AI frameworks, and services, refining the code until we attain a clearer understanding of what a modern LLM architecture stack might entail.</p> <p>You can find the code in the PromethAI-Memory repository</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#12-the-problem-of-putting-code-to-production","title":"1.2. The problem of putting code to production","text":"<p>Despite all the AI startup hype, there\u2019s a glaring issue lurking right under the surface: foundation models do not have production-ready data infrastructure by default</p> <p>Everyone seems to be building simple tools, like \u201cYour Sales Agent\u201d or \u201cYour HR helper,\u201d on top of OpenAI \u2014 a so-called\u00a0 \u201cThin Wrapper\u201d \u2014 and selling them as services.</p> <p>Our intention, however, is not to merely capitalize on this nascent industry \u2014 it\u2019s to use a new technology to catalyze a true digital paradigm shift\u00a0 \u2014 to paraphrase investor Marc Andreessen, content of the new medium as the content of the previous medium.</p> <p>What Andreessen meant by this is that each new medium for sharing information must encapsulate the content of the prior medium. For example, the internet encapsulates all books, movies, pictures, and stories from previous mediums.</p> <p>After a unified AI solution is created, only then will AI agents be able to proactively and competently operate the browsers, apps, and devices we operate by ourselves today.</p> <p>Intelligent agents in AI are programs capable of perceiving their environment, acting autonomously in order to achieve goals, and may improve their performance by learning or acquiring knowledge.</p> <p>The reality is that we now have a set of data platforms and AI agents that are becoming available to the general public, whose content and methods were previously inaccessible to anyone not privy to the tech-heavy languages of data scientists and engineers.</p> <p>As engineering tools move toward the mainstream, they need to become more intuitive and user friendly, while hiding their complexity with a set of background solutions.</p> <p>Fundamentally, the issue of \u201cThin wrappers\u201d is not an issue of bad products, but an issue of a lack of robust enough data engineering methods coupled with the general difficulties that come with creating production-ready code that relies on robust data platforms in a new space. </p> <p>The current lack of production-ready data systems for LLMs and AI Agents opens up a gap we want to fill\u00a0 by introducing robust data engineering practices to solve this issue.</p> <p>In this series of texts, our aim will thus be to explore what would constitute:</p> <ol> <li>Proper data engineering methods for LLMs</li> <li>A production-ready generative AI data platform that unlocks AI assistants/Agent Networks</li> </ol> <p>Each of the coming blog posts will be followed by Python code, to demonstrate the progress made toward building a modern AI data platform, raise important questions, and facilitate an open-source collaboration.</p> <p>Let\u2019s start by setting an attainable goal. As an example, let\u2019s conceptualize a production-ready process that can analyze and process hundreds of PDFs for hundreds of users.</p>  \ud83d\udca1 As a user, I want an AI Data Platform to enable me to extract, organize, and summarize data from PDF invoices so that it's seamlessly updated in the database and available for further processing.   <p>Imagine you're a developer, and you've got a stack of digital invoices in PDF format from various vendors. These PDFs are not just simple text files; they contain logos, varying fonts, perhaps some tables, and even handwritten notes or signatures.</p> <p>Your goal? To extract relevant information, such as vendor names, invoice dates, total amounts, and line-item details, among others.</p> <p>This task of analyzing PDFs may help us understand and define what a production-ready AI data platform entails. To perform the task, we\u2019ll be drawing a parallel between Data Engineering concepts and those from Cognitive Sciences which tap into our understanding of how human memory works \u2014 this should provide the baseline for the evaluation of the POCs in this post.</p> <p>We assume that Agent Networks of the future would resemble groups of humans with their own memory and unique contexts, all working and contributing toward a set of common objectives.</p> <p>In our example of data extraction from PDFs \u2014 a modern enterprise may have hundreds of thousands, if not millions of such documents stored in different places, with many people hired to make sense of them.</p> <p>This data is considered unstructured \u2014 you cannot handle it easily with current data engineering practices and database technology. The task to structure it is difficult and, to this day, has always needed to be performed manually.</p> <p>With the advent of Agent Networks, which mimic human cognitive abilities, we could start realistically structuring this kind of information at scale. As this is still data processing \u2014 an engineering task \u2014 we need to combine those two approaches.</p> <p>From an engineering standpoint, the next generation Data Platform needs to be built with the following in mind:</p> <ul> <li>We need to give Agents access to the data at scale.</li> <li>We need our Agents to operate like human minds so we need to provide them with tools to execute tasks and various types of memory for reasoning</li> <li>We need to keep the systems under control, meaning that we apply good engineering practices to the whole system</li> <li>We need to be able to test, sandbox, and roll back what Agents do and we need to observe them and log every action</li> </ul> <p>In order to conceptualize a new model of data structure and relationships that transcends the traditional Data Warehousing approach, we can start perceiving procedural steps in Agent execution flows as thoughts and interpreting them through the prism of human cognitive processes such as the functioning of our memory system and its memory components.</p> <p>Human memory can be divided into several distinct categories:</p> <ul> <li>Sensory Memory (SM) \u2192 Very short term (15-30s) memory storage unit receiving information from our senses.</li> <li>Short Term Memory (STM) \u2192 Short term memory that processes the information, and coordinates work based on information provided.</li> <li>Long-Term Memory (LTM) \u2192 Stores information long term, and retrieves what it needs for daily life.</li> </ul> <p>The general structure of human memory. Note that Weng doesn\u2019t expand on the STM here in the way we did above  :</p> <p></p> <p>Broader, more relevant representation of memory for our context, and the corresponding data processing, based on Atkinson-Schiffrin memory model would be:</p> <p></p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#2-level-0-the-current-state-of-affairs","title":"2. Level 0: The Current State of Affairs","text":"<p>To understand the current LLM production systems, how they handle data input and processing, and their evolution, we start at Level 0 \u2014 the LLMs and their APIs as they are currently \u2014 and progress toward Level 7 \u2014 AI Agents and complex AI Data Platforms and Agent Networks of the future.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#21-developer-intent-at-level-0","title":"2.1. Developer Intent at Level 0","text":"<p>In order to extract relevant data from PDF documents, as an engineer you would turn to a powerful AI model like OpenAI, Anthropic, or Cohere (Layer 0 in our XYZ stack). Not all of them support this functionality, so you\u2019d use Bing or a ChatGPT plugin like AskPDF, which do.</p> <p>In order to \"extract nuances,\" you might provide the model with specific examples or more directive prompts. For instance, \"Identify the vendor name positioned near the top of the invoice, usually above the billing details.\"</p> <p>Next, you'd \"prompt it\" with various PDFs to see how it reacts. Based on the outputs, you might notice that it misses handwritten dates or gets confused with certain fonts.</p> <p>This is where \"prompt engineering\" comes in. You might adjust your initial prompt to be more specific or provide additional context. Maybe you now say, \"Identify the vendor name and, if you find any handwritten text, treat it as the invoice date.\"</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#22-toward-the-production-code-from-the-chatbot-ux-poc-at-level-0","title":"2.2 Toward the production code from the chatbot UX - POC at level 0","text":"<p>Our POC at this stage consists of simply uploading a PDF and asking it questions until we have better and better answers based on prompt engineering. This exercise shows what is available with the current production systems, to help us set a baseline for the solutions to come.</p> <ul> <li>If your goal is to understand the content of a PDF, Bing and OpenAI will enable you to upload documents and get explanations of their contents</li> <li>Uses basic natural language processing (NLP) prompts without any schema on output data</li> <li>Typically \u201cforgets\u201d the data after a query \u2014 no notion of storage (LTM)</li> <li>In a production environment, data loss can have significant consequences. It can lead to operational disruptions, inaccurate analytics, and loss of valuable insights</li> <li>There is no possibility to test the behavior of the system</li> </ul> <p>Let\u2019s break down the Data Platform component at this stage:</p> Memory type State Description Sensory Memory Chatbot interface Can be interpreted in this context as the interface used for the human input STM The context window of the chatbot/search. In essence stateless The processing layer and a storage of the session/user context LTM Not present at this stage The information storage <p>Lacks:</p> <ul> <li>Decoupling: Separating components to reduce interdependency.</li> <li>Portability: Ability to run in different environments.</li> <li>Modularity: Breaking down into smaller, independent parts.</li> </ul> <p>Extendability: Capability to add features or functionality.</p> <p>Next Steps:</p> <ol> <li>Implement a LTM memory component for information retention.</li> <li>Develop an abstraction layer for Sensory Memory input and processing multiple file types.</li> </ol> <p>Addressing these points will enhance flexibility, reusability, and adaptability.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#23-summary-ask-pdf-questions","title":"2.3 Summary - Ask PDF questions","text":"Description Use-Case Summary Memory Maturity Production readiness The Foundational Model Extract info from your documents ChatGPT prompt engineering as the only way to optimise outputs SM, STM are system defined, LTM is not present Works 15% of time Lacks Decoupling, Portability, Modularity and Extendability","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#24-addendum-companies-in-the-space-openai-anthropic-and-cohere","title":"2.4. Addendum - companies in the space: OpenAI, Anthropic, and Cohere","text":"<ul> <li>A brief on each provider, relevant model and its role in the modern data space.</li> <li> <p>The list of models and providers in the space</p> Model Provider Structured data Speed Params Fine Tunability gpt-4 OpenAI\u00a0 Yes \u2605\u2606\u2606\u00a0 \u00a0- No gpt-3.5-turbo OpenAI Yes \u2605\u2605\u2606\u00a0 \u00a0175B No gpt-3 OpenAI No\u00a0 \u00a0\u2605\u2606\u2606 \u00a0175B No ada, babbage, curie \u00a0OpenAI No \u2605\u2605\u2605\u00a0 \u00a0350M - 7B Yes claude Anthropic\u00a0 No \u2605\u2605\u2606\u00a0 \u00a052B No\u00a0 claude-instant Anthropic\u00a0 No \u2605\u2605\u2605\u00a0 \u00a052B No command-xlarge Cohere No \u00a0\u2605\u2605\u2606 \u00a050B Yes command-medium Cohere No \u00a0\u2605\u2605\u2605 \u00a06B Yes BERT Google\u00a0 No \u2605\u2605\u2605\u00a0 345M\u00a0 Yes \u00a0T5 Google\u00a0 No \u2605\u2605\u2606\u00a0 \u00a011B Yes PaLM\u00a0 Google\u00a0 No \u00a0\u2605\u2606\u2606 \u00a0540B Yes LLaMA Meta AI\u00a0 Yes \u2605\u2605\u2606\u00a0 \u00a065B Yes \u00a0CTRL Salesforce\u00a0 No \u2605\u2605\u2605\u00a0 1.6B\u00a0 Yes Dolly 2.0\u00a0 Databricks No \u2605\u2605\u2606\u00a0 \u00a012B Yes\u00a0 </li> </ul>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#3-level-1-langchain-weaviate","title":"3**. Level 1:  Langchain &amp; Weaviate**","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#31-developer-intent-at-level-1-langchain-weaviate-llm-wrapper","title":"3.1. Developer Intent at Level 1**: Langchain &amp; Weaviate LLM Wrapper**","text":"<p>This step is basically an upgrade to the current state of the art LLM UX/UI where we add:</p> <ul> <li> <p>Permanent LTM memory (data store)</p> <p>As a developer, I need to answer questions on large PDFs that I can\u2019t simply pass to the LLM due to technical limitations. The primary issue being addressed is the constraint on prompt length. As of now, GPT-4 has a limit of 4k tokens for both the prompt and the response combined. So, if the prompt comprises 3.5k tokens, the response can only be 0.5k tokens long.</p> </li> <li> <p>LLM Framework like Langchain to adapt any document type to vector store</p> <p>Using Langchain provides a neat abstraction for me to get started quickly, connect to VectorDB, and get fast results.</p> </li> <li> <p>Some higher level structured storage (dlthub)</p> </li> </ul> <p></p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#32-translating-theory-into-practice-poc-at-level-1","title":"3.2. Translating Theory into Practice: POC at Level 1","text":"<ul> <li>LLMs can\u2019t process all the data that a large PDF could contain. So, we need a place to store the PDF and a way to retrieve relevant information from it, so it can be passed on to the LLM.</li> <li>When trying to build and process documents or user inputs, it\u2019s important to store them in a Vector Database to be able to retrieve the information when needed, along with the past context.</li> <li>A vector database is the optimal solution because it enables efficient storage, retrieval, and processing of high-dimensional data, making it ideal for applications like document search and user input analysis where context and similarity are important.</li> <li>For the past several months, there has been a surge of projects that personalize LLMs by storing user settings and information in a VectorDB so they can be easily retrieved and used as input for the LLM.</li> </ul> <p>This can be done by storing data in the Weaviate Vector Database; then, we can process our PDF.</p> <ul> <li>We start by converting the PDF and translating it</li> </ul> <p></p> <ul> <li>the next step we store the PDF to Weaviate</li> </ul> <p></p> <ul> <li>We load the data into some type of database using dlthub</li> </ul> <p></p> <p>The parallel with our memory components becomes clearer at this stage. We have some way to define inputs which correspond to SM, while STM and LTM are starting to become two separate, clearly distinguishable entities. It becomes evident that we need to separate LTM data according to domains it belongs to but, at this point, a clear structure for how that would work has not yet emerged.</p> <p>In addition, we can treat GPT as limited working memory and its context size as how much our model can remember during one operation.</p> <p>It\u2019s evident that, if we don\u2019t manage the working memory well, we will overload it and fail to retrieve outputs. So, we will need to take a closer look into how humans do the same and how our working memory manages millions of facts, emotions, and senses swirling around our minds.</p> <p>Let\u2019s break down the Data Platform components at this stage:</p> Memory type State Description Sensory Memory Command line interface + arguments Can be interpreted in this context as the arguments provided to the script STM Partially Vector store, partially working memory The processing layer and a storage of the session/user context LTM Vector store The raw document storage <p>Sensory Memory</p> <p>Sensory memory can be seen as an input buffer where the information from the environment is stored temporarily. In our case, it\u2019s the arguments we give to the command line script. </p> <p>STM</p> <p>STM is often associated with the concept of \"working memory,\" which holds and manipulates information for short periods.</p> <p>In our case, it is the time during which the process runs. </p> <p>LTM</p> <p>LTM can be conceptualized as a database in software systems. Databases store, organize, and retrieve data over extended periods. The information in LTM is organized and indexed, similar to how databases use tables, keys, and indexes to categorize and retrieve data efficiently.</p> <p>VectorDB: The LTM Storage of Our AI Data Platform</p> <p>Unlike traditional relational databases, that store data in tables, and newer NoSQL databases like MongoDB, that use JSON documents, vector databases specifically store and fetch vector embeddings.</p> <p>Vector databases are crucial for Large Language Models and other modern, resource-hungry applications. They're designed for handling vector data, commonly used in fields like computer graphics, Machine Learning, and Geographic Information Systems.</p> <p>Vector databases hinge on vector embeddings. These embeddings, packed with semantic details, help AI systems to understand data and retain long-term memory. They're condensed snapshots of training data and act as filters when processing new data in the inference stage of machine learning.</p> <p>Problems:</p> <ul> <li>Interoperability</li> <li>Maintainability</li> <li>Fault Tolerance</li> </ul> <p>Next steps:</p> <ol> <li>Create a standardized data model</li> <li>Dockerize the component</li> <li>Create a FastAPI endpoint</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#34-summary-the-thing-startup-bros-pitch-to-vcs","title":"3.4. Summary - The thing startup bros pitch to VCs","text":"Description Use-Case Summary Knowledge Maturity Production readiness Interface Endpoint for the Foundational Model Store data and query it for a particular use-case Langchain + Weaviate to improve user\u2019s conversations + prompt engineering to get better outputs SM is somewhat modifiable, STM is not clearly defined, LTM is a VectorDB Works 25% of time Lacks Interoperability, Maintainability, Fault Tolerance Has some: Reusability, Portability, Extendability","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#35-addendum-frameworks-and-vector-dbs-in-the-space-langchain-weaviate-and-others","title":"3.5. Addendum - Frameworks and Vector DBs in the space: Langchain, Weaviate and others","text":"<ul> <li>A brief on each provider, relevant model and its role in the modern data space.</li> <li> <p>The list of models and providers in the space</p> Tool/Service Tool type Ease of use Maturity Docs Production readiness Langchain Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 Weaviate VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 Pinecone VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2605\u2606\u00a0 ChromaDB VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2606\u2606\u00a0 Haystack Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 Huggingface's New Agent System Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 Milvus VectorDB \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 https://gpt-index.readthedocs.io/ Orchestration framework \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 \u2605\u2605\u2606\u00a0 \u2605\u2606\u2606\u00a0 </li> </ul>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#resources","title":"Resources","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#blog-posts","title":"Blog Posts:","text":"<ol> <li>Large Action Models</li> <li>Making Data Ingestion Production-Ready: A LangChain-Powered Airbyte Destination</li> <li>The Problem with LangChain</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#research-papers-arxiv","title":"Research Papers (ArXiv):","text":"<ol> <li>Research Paper 1</li> <li>Research Paper 2</li> <li>Research Paper 3</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#web-comics","title":"Web Comics:","text":"<ol> <li>xkcd comic</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#reddit-discussions","title":"Reddit Discussions:","text":"<ol> <li>Reddit Discussion: The Problem with LangChain</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#developer-blog-posts","title":"Developer Blog Posts:","text":"<ol> <li>Unlocking the Power of Enterprise-Ready LLMS with NeMo</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#industry-analysis","title":"Industry Analysis:","text":"<ol> <li>Emerging Architectures for LLM Applications</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#prompt-engineering","title":"Prompt Engineering:","text":"<ol> <li>Prompting Guide</li> <li>Tree of Thought Prompting: Walking the Path of Unique Approach to Problem Solving</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-and-towards-a-production-ready-modern-data-platform/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-2-towards-production/","title":"Going beyond Langchain + Weaviate: Level 2 towards Production","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-2-towards-production/#11-the-problem-of-putting-code-to-production","title":"1.1. The problem of putting code to production","text":"<p>This post is a part of a series of texts aiming to discover and understand patterns and practices that would enable building a production-ready AI data infrastructure. The main focus is on how to evolve data modeling and retrieval in order to enable Large Language Model (LLM) apps and Agents to serve millions of users concurrently.</p> <p>For a broad overview of the problem and our understanding of the current state of the LLM landscape, check out our previous post</p> <p></p> <p>In this text, we continue our inquiry into what would constitute:</p> <ol> <li>Proper data engineering methods for LLMs</li> <li>A production-ready generative AI data platform that unlocks AI assistants/Agent Networks</li> </ol> <p>To explore these points, we here at prometh.ai have partnered with dlthub in order to productionize a common use case \u2014 complex PDF processing \u2014 progressing level by level.</p> <p>In the previous text, we wrote a simple script that relies on the Weaviate Vector database to turn unstructured data into structured data and help us make sense of it.</p> <p>In this post, some of the shortcomings from the previous level will be addressed, including::</p> <ol> <li>Containerization</li> <li>Data model</li> <li>Data contract</li> <li>Vector Database retrieval strategies</li> <li>LLM context and task generation</li> <li>Dynamic Agent behavior and Agent tooling</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-2-towards-production/#3-level-2-memory-layer-fastapi-langchain-weaviate","title":"3. Level 2:  Memory Layer + FastAPI + Langchain + Weaviate","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-2-towards-production/#31-developer-intent-at-level-2","title":"3.1. Developer Intent at Level 2","text":"<p>This phase enhances the basic script by incorporating:</p> <ul> <li> <p>Memory Manager</p> <p>The memory manager facilitates the execution and processing of VectorDB data by:</p> <ol> <li>Uniformly applying CRUD (Create, Read, Update, Delete) operations across various classes</li> <li>Representing different business domains or concepts, and</li> <li>Ensuring they adhere to a common data model, which regulates all data points across the system.</li> <li>Context Manager</li> </ol> <p>This central component processes and analyzes data from Vector DB, evaluates its significance, and compares the results with user-defined benchmarks.</p> <p>The primary objective is to establish a mechanism that encourages in-context learning and empowers the Agent\u2019s adaptive understanding.</p> <p>As an example, let\u2019s assume we uploaded the book A Call of the Wild by Jack London to our Vector DB semantic layer, to give our LLM a better understanding of the life of sled dogs in the early 1900s.</p> <p>Asking a question about the contents of the book will yield a straightforward answer, provided that the book contains an explicit answer to our question.</p> <p>To enable better question answering and access to additional information such as historical context, summaries, and other documents, we need to introduce different memory stores and a set of attention modulators, which are meant to manage the prioritization of data retrieved for the answers.</p> </li> <li> <p>Task Manager</p> <p>Utilizing the tools at hand and guided by the user's prompt, the task manager determines a sequence of actions and their execution order.</p> <p>For example, let\u2019s assume that the user asks: \u201cWhen was Buck (one of the dogs from A Call of the Wild) kidnapped\u201d and to have the answer translated to German\u201d</p> <p>This query would be broken down by the task manager into a set of atomic tasks that can then be handed over to the Agent.</p> <p>The ordered task list could be:</p> <ol> <li>Retrieve information about the PDF from the database.</li> <li>Translate the information to German.</li> <li>The Agent</li> </ol> <p>AI agents can use computers independently. They can browse the web, use apps, read and write files, make credit card payments, and even autonomously execute processes on your personal computer.</p> <p>In our case, the Agent has only a few tools at its disposal, such as tools to translate text or structure data. Using these tools, it processes and executes tasks in the sequence they are provided by the Task Manager and the Context Manager.</p> </li> </ul>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-2-towards-production/#32-toward-the-memory-layer-poc-at-level-2","title":"3.2 Toward the memory layer - POC at level 2","text":"<p>At this stage, our proof of concept (POC) allows uploading a PDF document and requesting specific actions on it such as \"load to database\", \"translate to German\", or \"convert to JSON.\" Prior task resolutions and potential operations are assessed by the Context Manager and Task Manager services.</p> <p>The following set of steps explains the workflow of the POC at level 2:</p> <ul> <li>Initially, we specify the parameters for the document we wish to upload and define our objective in the prompt:</li> </ul> <p></p> <ul> <li> <p>The memory manager retrieves the parameters and the attention modulators and creates context based on Episodic and Semantic memory stores (previous runs of the job + raw data):</p> <p></p> </li> <li> <p>To do this, it starts by filtering user input, in the same way our brains filter important from redundant information. As an example, if there are children playing and talking loudly in the background during our Zoom meeting, we can still pool our attention together and focus on what the person on the other side is saying.</p> <p>The same principle is applied here:</p> </li> </ul> <p></p> <ul> <li> <p>In the next step, we apply a set of attention modulators to process the data obtained from the Vector Store.</p> <p>NOTE: In cognitive science, attention modulators can be thought of as factors or     mechanisms that influence the direction and intensity of attention.</p> <p>As we have many memory stores, we need to prioritize the data points that we retrieve via semantic search.</p> <p>Since semantic search is not enough by itself, scoring data points happens via a set of functions that replicate how attention modulators work in cognitive science.</p> <p>Initially, we\u2019ve implemented a few attention modulators that we thought could improve the document retrieval process:</p> <p>Frequency: This refers to how often a specific stimulus or event is encountered. Stimuli that are encountered more frequently are more likely to be attended to or remembered.</p> <p>Recency: This refers to how recently a stimulus or event was encountered. Items or events that occurred more recently are typically easier to recall than those that occurred a long time ago.</p> </li> </ul> <p>We have implemented many more, and you can find them in our</p> <p>repository. More are still needed and contributions are more than welcome.</p> <p>Let\u2019s see the modulators in action:</p> <p></p> <p>In the code above we fetch the memories from the Semantic Memory bank where our knowledge of the world is stored (the PDFs). We select the relevant documents by using the handle_modulator function.</p> <ul> <li>The handle_modulator function is defined below and explains how scoring of memories happens.</li> </ul> <p></p> <p>We process the data retrieved with OpenAI functions and store the results for the Task Manager to be able to determine what actions the Agent should take.</p> <p>The Task Manager then sorts and converts user input into a set of actionable steps based on the tools available.</p> <p></p> <p>Finally, the Agent interprets the context and performs the steps using the tools it has available. We see this as the step where the Agents take over the task, executing it in their own way.</p> <p>Now, let's look back at what constitutes the Data Platform:</p> Memory type State Description Sensory Memory API Can be interpreted in this context as the interface used for the human input STM Weaviate Class with hardcoded contract The processing layer and a storage of the session/user context LTM Weaviate Class with hardcoded contract The information storage <p>Lacks:</p> <ul> <li>Extendability: Capability to add features or functionality.</li> <li>Loading flexibility: Ability to apply different chunking strategies</li> <li>Testability: How to test the code and make sure it runs</li> </ul> <p>Next Steps:</p> <ol> <li>Implement different strategies for vector search</li> <li>Add more tools to process PDFs</li> <li>Add more attention modulators</li> <li>Add a solid test framework</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-2-towards-production/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/","title":"Going beyond Langchain + Weaviate: Level 3 towards production","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/#preface","title":"Preface","text":"<p>This post is part of a series of texts aiming to explore and understand patterns and practices that enable the construction of a production-ready AI data infrastructure. The main focus of the series is on the modeling and retrieval of evolving data, which would empower Large Language Model (LLM) apps and Agents to serve millions of users concurrently.</p> <p>For a broad overview of the problem and our understanding of the current state of the LLM landscape, check out our initial post here.</p> <p>In this post, we delve into context enrichment and testing in Retrieval Augmented Generation (RAG) applications.</p> <p>RAG applications can retrieve relevant information from a knowledge base and generate detailed, context-aware answers to user queries.</p> <p>As we are trying to improve on the base information LLMs are giving us, we need to be able to retrieve and understand more complex data, which can be stored in various data stores, in many formats, and using different techniques.</p> <p>All of this leads to a lot of opportunities, but also creates a lot of confusion in generating and using RAG applications and extending the existing context of LLMs with new knowledge.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/#1-context-enrichment-and-testing-in-rag-applications","title":"1. Context Enrichment and Testing in RAG Applications","text":"<p>In navigating the complexities of RAG applications, the first challenge we face is the need for robust testing. Determining whether augmenting a LLM's context with additional information will yield better results is far from straightforward and often relies on subjective assessments.</p> <p>Imagine, for instance, adding the digital version of the book The Adventures of Tom Sawyer to the LLM's database in order to enrich its context and obtain more detailed answers about the book's content for a paper we're writing. To evaluate this enhancement, we need a way to measure the accuracy of the responses before and after adding the book while considering the variations of every adjustable parameter.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/#2-adjustable-parameters-in-rag-applications","title":"2. Adjustable Parameters in RAG Applications","text":"<p>The end-to-end process of enhancing RAG applications involves various adjustable parameters, which offer multiple paths toward achieving similar goals with varying outcomes. These parameters include:</p> <ol> <li>Number of documents loaded into memory.</li> <li>Size of each sub-document chunk uploaded.</li> <li>Overlap between documents uploaded.</li> <li>Relationship between documents (Parent-Son etc.)</li> <li>Type of embedding used for data-to-vector conversion (OpenAI, Cohere, or any other embedding method).</li> <li>Metadata structure for data navigation.</li> <li>Indexes and data structures.</li> <li>Search methods (text, semantic, or fusion search).</li> <li>Output retrieval and scoring methods.</li> <li>Integration of outputs with other data for in-context learning.</li> <li>Structure of the final output.</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/#3-the-role-of-memory-manager-at-level-3","title":"3. The Role of Memory Manager at Level 3","text":"<p>Memory Layer + FastAPI + Langchain + Weaviate</p> <p>3.1. Developer Intent at Level 3</p> <p>The goal we set for our system in our initial post \u2014 processing and creating structured data from PDFs \u2014 presented an interesting set of problems to solve. OpenAI functions and dlthub allowed us to accomplish this task relatively quickly.</p> <p>The real issue arises when we try to scale this task \u2014 this is what our second post tried to address. In addition, retrieving meaningful data from the Vector Databases turned out to be much more challenging than initially imagined.</p> <p>In this post, we\u2019ll discuss how we can establish a testing method, improve our ability to retrieve the information we've processed, and make the codebase more robust and production-ready.</p> <p>We\u2019ll primarily focus on the following:</p> <ol> <li> <p>Memory Manager</p> <p>The Memory Manager is a set of functions and tools for creating dynamic memory objects. In our previous blog posts, we explored the application of concepts from cognitive science \u2014\u00a0 Short-Term Memory, Long-Term Memory, and Cognitive Buffer \u2014 on Agent Network development.</p> <p>We might need to add more memory domains to the process, as sticking to just these three can pose limitations. Changes in the codebase now enable real-time creation of dynamic memory objects, which have hierarchical relationships and can relate to each other.</p> </li> <li> <p>RAG test tool</p> <p>The RAG test tool allows us to control critical parameters for optimizing and testing RAG applications, including chunk size, chunk overlap, search type, metadata structure, and more.</p> </li> </ol> <p>The Memory Manager is a crucial component of any cognitive architecture platform. In our previous posts, we\u2019ve discussed how to turn unstructured data to structured, how to relate concepts to each other in the vector store, and which problems can arise when productionizing these systems.</p> <p>While we\u2019ve addressed many open questions, many still remain. Based on our surveys and interviews with field experts, applications utilizing Memory components face the following challenges:</p> <ol> <li> <p>Inability to reliably link between Memories</p> <p>Relying solely on semantic search or its derivatives to recognize the similarities between terms like \"pair\" and \"combine\" is a step forward. However, actually defining, capturing, and quantifying the relationships between any two objects would aid future memory access.</p> <p>Solution: Graphs/Traditional DB</p> </li> <li> <p>Failure to structure and organize Memories</p> <p>We used OpenAI functions to structure and organize different Memory elements and convert them into understandable JSONs. Nevertheless, our surveys indicate that many people struggle with metadata management and the structure of retrievals. Ideally, these aspects should all be managed and organized in one place.</p> <p>Solution: OpenAI functions/Data contracting/Metadata management</p> </li> <li> <p>Hierarchy, size, and relationships of individual Memory elements</p> <p>Although semantic search helps us understand the same concepts, we need to add more abstract concepts and ideas and link them. The ultimate goal is to emulate human understanding of the world, which comprises basic concepts that, when combined, create higher complexity objects.</p> <p>Solution: Graphs/Custom solutions</p> </li> <li> <p>Evaluation possibilities of memory components (can they be distilled to True/False)</p> <p>Based on the psycholinguistic theories proposed by Walter Kintsch, any cognitive system should be able to provide True/False evaluations. Kintsch defines a basic memory component, a \u2018proposition,\u2019 which can be evaluated as True or False and can interlink with other Memory components.</p> <p>A proposition could be, for example, \"The sky is blue,\" and its evaluation to True/False could lead to actions such as \"Do not bring an umbrella\" or \"Wear a t-shirt.\"</p> <p>Potential solution: Particular memory structure</p> </li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/#testability-of-memory-components","title":"Testability of Memory components","text":"<p>We should have a reliable method to test Memory components, at scale, for any number of use-cases. We need benchmarks across every level of testing to capture and define predicted behavior.</p> <p>Suppose we need to test if Memory data from six months ago can be retrieved by our system and measure how much it contributes to a response that spans memories that are years old.</p> <p>Solution: RAG testing framework</p> <p></p> <p>Let\u2019s look at the RAG testing framework:</p> <p>It allows to you to test and combine all variations of: </p> <ol> <li>Number of documents loaded into memory.  \u2705</li> <li>Size of each sub-document chunk uploaded. \u2705</li> <li>Overlap between documents uploaded.  \u2705</li> <li>Relationship between documents (Parent-Son etc.) \ud83d\udc77\ud83c\udffb\u200d\u2642\ufe0f</li> <li>Type of embedding used for data-to-vector conversion (OpenAI, Cohere, or any other embedding method).  \u2705</li> <li>Metadata structure for data navigation.  \u2705</li> <li>Indexes and data structures.  \u2705</li> <li>Search methods (text, semantic, or fusion search).  \u2705</li> <li>Output retrieval and scoring methods. \ud83d\udc77\ud83c\udffb\u200d\u2642\ufe0f</li> <li>Integration of outputs with other data for in-context learning. \ud83d\udc77\ud83c\udffb\u200d\u2642\ufe0f</li> <li>Structure of the final output.  \u2705</li> </ol> <p>These parameters and results of the tests will be stored in Postgres database and can be visualized using Superset</p> <p>To try it, navigate to: https://github.com/topoteretes/PromethAI-Memory</p> <p>Copy the .env.template to .env and fill in the variables</p> <p>Specify the environment variable in the .env file to \"local\"</p> <p>Use the poetry environment:</p> <p><code>poetry shell</code></p> <p>Change the .env file Environment variable to \"local\"</p> <p>Launch the postgres DB</p> <p><code>docker compose up postgres</code></p> <p>Launch the superset</p> <p><code>docker compose up superset</code></p> <p>Open the superset in your browser</p> <p><code>http://localhost:8088</code>\u00a0Add the Postgres datasource to the Superset with the following connection string:</p> <p><code>postgres://bla:bla@postgres:5432/bubu</code></p> <p>Make sure to run to initialize DB tables</p> <p><code>python scripts/create_database.py</code></p> <p>After that, you can run the RAG test manager from your command line.</p> <pre><code>    python rag_test_manager.py \\\n    --file \".data\" \\\n    --test_set \"example_data/test_set.json\" \\\n    --user_id \"97980cfea0067\" \\\n    --params \"chunk_size\" \"search_type\" \\\n    --metadata \"example_data/metadata.json\" \\\n    --retriever_type \"single_document_context\"\n</code></pre> <p>Examples of metadata structure and test set are in the folder \"example_data\"</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/10/05/going-beyond-langchain--weaviate-level-3-towards-production/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/12/05/going-beyond-langchain--weaviate-level-4-towards-production/","title":"Going beyond Langchain + Weaviate: Level 4 towards production","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/12/05/going-beyond-langchain--weaviate-level-4-towards-production/#preface","title":"Preface","text":"<p>This post is part of a series of texts aiming to explore and understand patterns and practices that enable the construction of a production-ready AI data infrastructure. The series mainly focuses on the modeling and retrieval of evolving data, which would empower Large Language Model (LLM) apps and Agents to serve millions of users concurrently.</p> <p>For a broad overview of the problem and our understanding of the current state of the LLM landscape, check out our initial post here.</p> <p></p> <p>In this post, we delve into creating an initial data platform that can represent the core component of the future MlOps stack. Building a data platform is a big challenge in itself, and many solutions are available to help automate data tracking, ingestion, data contracting, monitoring, and warehousing.</p> <p>In the last decade, data analytics and engineering fields have undergone significant transformations, shifting from storing data in centralized, siloed Oracle and SQL Server warehouses to a more agile, modular approach involving real-time data and cloud solutions like BigQuery and Snowflake.</p> <p>Data processing evolved from an inessential activity, whose value would be inflated to please investors during the startup valuation phase, to a fundamental component of product development.</p> <p>As we enter a new paradigm of interacting with systems through natural language, it's important to recognize that, while this method promises efficiency, it also comes with the challenges inherent in the imperfections of human language.</p> <p>Suppose we want to use natural language as a new programming tool. In that case, we will need to either impose more constraints on it or make our systems more flexible so that they can adapt to the equivocal nature of language and information.</p> <p>Our main goal should be to offer consistency, reproducibility and more that would ideally use language as a basic building block for things to come.</p> <p>In order to come up with a set of solutions that could enable us to move forward, in this series of posts, we call on theoretical models from cognitive science and try to incorporate them into data engineering practices .</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/12/05/going-beyond-langchain--weaviate-level-4-towards-production/#level-4-memory-architecture-and-a-first-integration-with-keepiai","title":"Level 4: Memory architecture and a first integration with keepi.ai","text":"<p>In our initial post, we started out conceptualizing a simple retrieval-augmented generation (RAG) model whose aim was to process and understand PDF documents.</p> <p>We faced many bottlenecks in scaling these tasks, so in our second post, we needed to introduce the concept of memory domains..</p> <p>In the next step, the focus was mainly on understanding what makes a good RAG considering all possible variables.</p> <p>In this post, we address the fundamental question of the feasibility of extending LLMs beyond the data on which they were trained.</p> <p>As a Microsoft research team recently stated:</p> <ul> <li>Baseline RAG struggles to connect the dots when answering a question requires providing synthesized insights by traversing disparate pieces of information through their shared attributes.</li> <li>Baseline RAG performs poorly when asked to understand summarized semantic concepts holistically over large data collections or even singular large documents.</li> </ul> <p>To fill these gaps in RAG performance, we built a new framework\u2014cognee.</p> <p>Cognee combines human-inspired cognitive processes with efficient data management practices, infusing data points with more meaningful relationships to represent the (often messy) natural world in code more accurately.</p> <p>Our observations indicate that systems, agents, and interactions often falter due to overextension and haste.</p> <p>However, given the extensive demands and expectations surrounding Large Language Models (LLMs), addressing every aspect\u2014agents, actions, integrations, and schedulers\u2014is beyond the scope of the framework\u2019s mission.</p> <p>We've chosen to prioritize data, recognizing that the crux of many issues has already been addressed within the realm of data engineering.</p> <p>We aim to establish a framework that includes file storage, tracing, and the development of robust AI memory data pipelines to help us manage and structure data more efficiently through its transformation processes.</p> <p>Subsequently, our goal will be to devise methods for navigating diverse information segments and determine the most effective application of graph databases to store this data.</p> <p>Our initial hypothesis\u2014enhancing data management in vector stores through manipulative techniques and attention modulators for input and retrieval\u2014proved less effective than anticipated.</p> <p>Deconstructing and reorganizing data via graph databases emerged as a superior strategy, allowing us to adapt and repurpose existing tools for our needs more effectively.</p> AI Memory type State in Level 2 State in Level 4 Description Sensory Memory API API Can be interpreted in this context as the interface used for the human input STM Weaviate Class with hardcoded contract Neo4j  with a connection to a Weaviate class The processing layer and a storage of the session/user context LTM Weaviate Class with hardcoded contract Neo4j with a connection to a Weaviate class The information storage <p>On Level 4, we describe the integration of keepi, a chatGPT-powered WhatsApp bot that collects and summarizes information, via API endpoints.</p> <p>Then, once we\u2019ve ensured that we have a robust, scalable infrastructure, we deploy cognee to the cloud.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/12/05/going-beyond-langchain--weaviate-level-4-towards-production/#workflow-overview","title":"Workflow Overview","text":"<p>Steps:</p> <ol> <li>Users submit queries or documents for storage via the keepi.ai WhatsApp bot. This step integrates with the keepi.ai platform, utilizing Cognee endpoints for processing.</li> <li>The Cognee manager handles the incoming request and collaborates with several components:<ol> <li>Relational database: Manages state and metadata related to operations.</li> <li>Classifier: Identifies, organizes, and enhances the content.</li> <li>Loader: Archives data in vector databases.</li> </ol> </li> <li>The Graph Manager and Vector Store Manager collaboratively process and organize the input into structured nodes. A key function of the system involves breaking down user input into propositions\u2014basic statements retaining factual content. These propositions are interconnected through relationships and cataloged in the Neo4j database by the Graph Manager, associated with specific user nodes. Users are represented by memory nodes that capture various memory levels, some of which link back to the raw data in vector databases.</li> </ol>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/12/05/going-beyond-langchain--weaviate-level-4-towards-production/#whats-next","title":"What\u2019s next","text":"<p>We're diligently developing our upcoming features, with key objectives including:</p> <ol> <li>Numerically defining and organizing the strengths of relationships within graphs.</li> <li>Creating a structured data model with opinions to facilitate document structure and data extraction.</li> <li>Converting Cognee into a Python library for easier integration.</li> <li>Broadening our database compatibility to support a broader range of systems.</li> </ol> <p>Make sure to explore our implementation on GitHub, and, if you find it valuable, consider starring it to show your support.</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/2023/12/05/going-beyond-langchain--weaviate-level-4-towards-production/#conclusion","title":"Conclusion","text":"<p>If you enjoy the content or want to try out <code>cognee</code> please check out the github and give us a star!</p>","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"blog/rag/rag_explained/","title":"tbd","text":"","tags":["pydantic","langchain","llm","openai","functions","pdfs"]},{"location":"concepts/graph_data_models/","title":"Graph data models","text":"<p>Graph data models are fundamental structures used to represent and store data in the form of graphs, which consist of nodes (or vertices) and edges (or links). This model is particularly effective for illustrating relationships and connections among various data entities, making it invaluable in domains such as social networks, recommendation systems, logistics, biological networks, and more. Here's an overview of key concepts and types of graph data models:</p> <p>Key Concepts: Nodes (Vertices): Represent entities or objects within the graph, such as people in a social network, stations in a transportation map, or proteins in biological networks. Edges (Links): Depict the relationships or interactions between nodes. Edges can be directed (indicating a one-way relationship) or undirected (indicating a mutual relationship). Properties: Both nodes and edges can have properties (key-value pairs) that provide additional information, such as weights, types, or other attributes relevant to the application.</p>"},{"location":"concepts/llm_structured_outputs/","title":"Llm structured outputs","text":"<p>Function calling in the context of Large Language Models (LLMs) like GPT-3, GPT-4, and their derivatives extends beyond traditional programming paradigms. In this scenario, function calling involves prompting the LLM to simulate the behavior of a function within its generated output. This capability allows users to interact with LLMs in a structured way, effectively requesting specific operations or information retrieval tasks by framing their prompts as function calls.</p> <p>How LLM Function Calling Works: Prompt Construction: The user constructs a prompt that mimics a function call in programming. This prompt includes the \"name\" of the function (often a description of the task) and the \"arguments\" (the specific inputs or conditions for the task). For example, a prompt might look like \"Generate a summary for the following article:\" followed by the article text.</p> <p>LLM Interpretation: The LLM interprets this structured prompt and understands it as a request to perform a specific task, similar to how a function in a program would be invoked. The model then generates an output that aligns with the expected behavior of the function described in the prompt.</p> <p>Parameters and Outputs: In LLM function calling, the parameters are the details provided in the prompt, and the output is the generated text that the model produces in response. This output is intended to fulfill the function's \"purpose\" as inferred from the prompt.</p>"},{"location":"concepts/multilayer_graph_networks/","title":"Multilayer graph networks","text":"<p>A multilayer graph network is a sophisticated structure used to model complex systems where entities and their interactions can exist in multiple layers, each representing a different type of relationship, context, or domain. Unlike traditional graphs that capture connections in a single, uniform setting, multilayer graphs provide a more nuanced framework, allowing for the representation of diverse interconnections and dependencies across various dimensions or layers. </p>"},{"location":"concepts/propositions/","title":"Propositions","text":"<p>Propositions are fundamental elements in the study of logic, linguistics, and natural language processing. They represent atomic expressions within texts that encapsulate distinct factoids, conveying specific pieces of information. In essence, a proposition is a declarative statement that can either be true or false, but not both simultaneously. This binary nature makes propositions crucial for logical deductions, reasoning, and the construction of arguments.</p> <p>In a natural language context, propositions are presented in a concise and self-contained format.  They are designed to convey information clearly and unambiguously, making them easily interpretable by humans and computable by machines. For example, the statement \"The Eiffel Tower is in Paris\" is a proposition because it presents a specific fact about the location of the Eiffel Tower, and its truth value can be assessed as either true or false.</p> <p>The concept of propositions extends beyond mere statements of fact to include assertions about concepts, relationships, and conditions.  For instance, \"If it rains, the ground gets wet\" is a conditional proposition that establishes a cause-and-effect relationship between two events.</p> <p>In computational linguistics and natural language processing, propositions are vital for tasks such as information extraction, knowledge representation, and question answering.</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2023/","title":"2023","text":""}]}